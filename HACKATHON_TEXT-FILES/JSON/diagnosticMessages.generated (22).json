{
        "error TS{0}: {1}": "오류 TS{0}: {1}",
        "warning TS{0}: {1}": "경고 TS{0}: {1}",
        "Unrecognized escape sequence.": "인식할 수 없는 이스케이프 시퀀스입니다.",
        "Unexpected character {0}.": "예기치 않은 {0} 문자입니다.",
        "Missing close quote character.": "닫는 따옴표 문자가 없습니다.",
        "Identifier expected.": "식별자가 필요합니다.",
        "'{0}' keyword expected.": "'{0}' 키워드가 필요합니다.",
        "'{0}' expected.": "'{0}'이(가) 필요합니다.",
        "Identifier expected; '{0}' is a keyword.": "식별자가 필요합니다. '{0}'은(는) 키워드입니다.",
        "Automatic semicolon insertion not allowed.": "자동으로 세미콜론을 삽입할 수 없습니다.",
        "Unexpected token; '{0}' expected.": "예기치 않은 토큰입니다. 필요한 토큰은 '{0}'입니다.",
        "Trailing separator not allowed.": "후행 구분 기호를 사용할 수 없습니다.",
        "'*/' expected.": "'*/'가 필요합니다.",
        "'public' or 'private' modifier must precede 'static'.": "'public' 또는 'private' 한정자는 'static' 앞에 와야 합니다.",
        "Unexpected token.": "예기치 않은 토큰입니다.",
        "Catch clause parameter cannot have a type annotation.": "catch 절 매개 변수에는 형식 주석을 사용할 수 없습니다.",
        "Rest parameter must be last in list.": "Rest 매개 변수는 목록 마지막에 있어야 합니다.",
        "Parameter cannot have question mark and initializer.": "매개 변수에 물음표와 이니셜라이저를 사용할 수 없습니다.",
        "Required parameter cannot follow optional parameter.": "필수 매개 변수가 선택적 매개 변수 뒤에 올 수 없습니다.",
        "Index signatures cannot have rest parameters.": "인덱스 시그니처에 rest 매개 변수를 사용할 수 없습니다.",
        "Index signature parameter cannot have accessibility modifiers.": "인덱스 시그니처 매개 변수에 액세스 가능성 한정자를 사용할 수 없습니다.",
        "Index signature parameter cannot have a question mark.": "인덱스 시그니처 매개 변수에 물음표를 사용할 수 없습니다.",
        "Index signature parameter cannot have an initializer.": "인덱스 시그니처 매개 변수에 이니셜라이저를 사용할 수 없습니다.",
        "Index signature must have a type annotation.": "인덱스 시그니처에 형식 주석이 있어야 합니다.",
        "Index signature parameter must have a type annotation.": "인덱스 시그니처 매개 변수에 형식 주석이 있어야 합니다.",
        "Index signature parameter type must be 'string' or 'number'.": "인덱스 시그니처 매개 변수 형식이 'string' 또는 'number'여야 합니다.",
        "'extends' clause already seen.": "'extends' 절이 이미 있습니다.",
        "'extends' clause must precede 'implements' clause.": "'extends' 절은 'implements' 절 앞에 와야 합니다.",
        "Classes can only extend a single class.": "클래스는 단일 클래스만 확장할 수 있습니다.",
        "'implements' clause already seen.": "'implements' 절이 이미 있습니다.",
        "Accessibility modifier already seen.": "액세스 가능성 한정자가 이미 있습니다.",
        "'{0}' modifier must precede '{1}' modifier.": "'{0}' 한정자는 '{1}' 한정자 앞에 와야 합니다.",
        "'{0}' modifier already seen.": "'{0}' 한정자가 이미 있습니다.",
        "'{0}' modifier cannot appear on a class element.": "'{0}' 한정자는 클래스 요소에 나타날 수 없습니다.",
        "Interface declaration cannot have 'implements' clause.": "인터페이스 선언에 'implements' 절을 사용할 수 없습니다.",
        "'super' invocation cannot have type arguments.": "'super' 호출에 형식 인수를 사용할 수 없습니다.",
        "Only ambient modules can use quoted names.": "앰비언트 모듈만 따옴표가 붙은 이름을 사용할 수 있습니다.",
        "Statements are not allowed in ambient contexts.": "앰비언트 컨텍스트에서는 문이 허용되지 않습니다.",
        "Implementations are not allowed in ambient contexts.": "앰비언트 컨텍스트에서는 구현이 허용되지 않습니다.",
        "'declare' modifier not allowed for code already in an ambient context.": "이미 앰비언트 컨텍스트에 있는 코드에 'declare' 한정자를 사용할 수 없습니다.",
        "Initializers are not allowed in ambient contexts.": "앰비언트 컨텍스트에서는 이니셜라이저가 허용되지 않습니다.",
        "Parameter property declarations can only be used in a non-ambient constructor declaration.": "매개 변수 속성 선언은 앰비언트가 아닌 생성자 선언에서만 사용할 수 있습니다.",
        "Function implementation expected.": "함수 구현이 필요합니다.",
        "Constructor implementation expected.": "생성자 구현이 필요합니다.",
        "Function overload name must be '{0}'.": "함수 오버로드 이름이 '{0}'이어야 합니다.",
        "'{0}' modifier cannot appear on a module element.": "'{0}' 한정자는 모듈 요소에 나타날 수 없습니다.",
        "'declare' modifier cannot appear on an interface declaration.": "'declare' 한정자는 인터페이스 선언에 나타날 수 없습니다.",
        "'declare' modifier required for top level element.": "'declare' 한정자는 최상위 요소에 필요합니다.",
        "Rest parameter cannot be optional.": "Rest 매개 변수는 선택 사항이 될 수 없습니다.",
        "Rest parameter cannot have an initializer.": "Rest 매개 변수에는 이니셜라이저를 사용할 수 없습니다.",
        "'set' accessor must have one and only one parameter.": "'set' 접근자에는 매개 변수가 하나만 있어야 합니다.",
        "'set' accessor parameter cannot be optional.": "'set' 접근자 매개 변수는 선택 사항이 될 수 없습니다.",
        "'set' accessor parameter cannot have an initializer.": "'set' 접근자 매개 변수에는 이니셜라이저를 사용할 수 없습니다.",
        "'set' accessor cannot have rest parameter.": "'set' 접근자에는 rest 매개 변수를 사용할 수 없습니다.",
        "'get' accessor cannot have parameters.": "'get' 접근자에는 매개 변수를 사용할 수 없습니다.",
        "Modifiers cannot appear here.": "한정자를 여기에 표시할 수 없습니다.",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "접근자는 ECMAScript 5 이상을 대상으로 지정할 때만 사용할 수 있습니다.",
        "Class name cannot be '{0}'.": "클래스 이름은 '{0}'일 수 없습니다.",
        "Interface name cannot be '{0}'.": "인터페이스 이름은 '{0}'일 수 없습니다.",
        "Enum name cannot be '{0}'.": "열거형 이름은 '{0}'일 수 없습니다.",
        "Module name cannot be '{0}'.": "모듈 이름은 '{0}'일 수 없습니다.",
        "Enum member must have initializer.": "열거형 멤버에는 이니셜라이저가 있어야 합니다.",
        "Export assignment cannot be used in internal modules.": "내부 모듈에서는 내보내기 할당을 사용할 수 없습니다.",
        "Export assignment not allowed in module with exported element.": "내보낸 요소가 있는 모듈에는 할당 내보내기를 사용할 수 없습니다.",
        "Module cannot have multiple export assignments.": "모듈에 할당 내보내기를 여러 개 사용할 수 없습니다.",
        "Ambient enum elements can only have integer literal initializers.": "앰비언트 열거형 요소에는 정수 리터럴 이니셜라이저만 사용할 수 있습니다.",
        "module, class, interface, enum, import or statement": "모듈, 클래스, 인터페이스, 열거형, 가져오기 또는 문",
        "constructor, function, accessor or variable": "생성자, 함수, 접근자 또는 변수",
        "statement": "문",
        "case or default clause": "케이스 또는 기본 절",
        "identifier": "식별자",
        "call, construct, index, property or function signature": "호출, 구문, 인덱스, 속성 또는 함수 시그니처",
        "expression": "식",
        "type name": "형식 이름",
        "property or accessor": "속성 또는 접근자",
        "parameter": "매개 변수",
        "type": "형식",
        "type parameter": "형식 매개 변수",
        "'declare' modifier not allowed on import declaration.": "'declare' 한정자는 Import 선언에 사용할 수 없습니다.",
        "Function overload must be static.": "함수 오버로드는 정적이어야 합니다.",
        "Function overload must not be static.": "함수 오버로드는 정적이 아니어야 합니다.",
        "Parameter property declarations cannot be used in a constructor overload.": "매개 변수 속성 선언은 생성자 오버로드에서 사용할 수 없습니다.",
        "Invalid 'reference' directive syntax.": "'reference' 지시문 구문이 잘못되었습니다.",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "ECMAScript 5 이상을 대상으로 지정할 때는 8진수 리터럴을 사용할 수 없습니다.",
        "Accessors are not allowed in ambient contexts.": "앰비언트 컨텍스트에서는 접근자가 허용되지 않습니다.",
        "'{0}' modifier cannot appear on a constructor declaration.": "'{0}' 한정자는 생성자 선언에 표시될 수 없습니다.",
        "'{0}' modifier cannot appear on a parameter.": "'{0}' 한정자는 매개 변수에 표시될 수 없습니다.",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "'for...in' 문에는 단일 변수 선언만 허용됩니다.",
        "Type parameters cannot appear on a constructor declaration.": "형식 매개 변수는 생성자 선언에 표시될 수 없습니다.",
        "Type annotation cannot appear on a constructor declaration.": "형식 주석은 생성자 선언에 표시될 수 없습니다.",
        "Duplicate identifier '{0}'.": "'{0}' 식별자가 중복되었습니다.",
        "The name '{0}' does not exist in the current scope.": "이름 '{0}'이(가) 현재 범위에 없습니다.",
        "The name '{0}' does not refer to a value.": "이름 '{0}'이(가) 값을 참조하지 않습니다.",
        "'super' can only be used inside a class instance method.": "'super'는 클래스 인스턴스 메서드 안에만 사용할 수 있습니다.",
        "The left-hand side of an assignment expression must be a variable, property or indexer.": "할당식의 왼쪽은 변수, 속성 또는 인덱서여야 합니다.",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "'{0}' 형식의 값은 호출할 수 없습니다. 'new'를 포함하려고 했습니까?",
        "Value of type '{0}' is not callable.": "'{0}' 형식의 값은 호출할 수 없습니다.",
        "Value of type '{0}' is not newable.": "'{0}' 형식의 값은 새로 입력할 수 없습니다.",
        "Value of type '{0}' is not indexable by type '{1}'.": "'{0}' 형식의 값을 '{1}' 형식으로 인덱싱할 수 없습니다.",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "'{0}' 연산자를 '{1}' 및 '{2}' 형식에 적용할 수 없습니다.",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": "'{0}' 연산자를 '{1}' 및 '{2}' 형식에 적용할 수 없습니다. {3}",
        "Cannot convert '{0}' to '{1}'.": "'{0}'을(를) '{1}'(으)로 변환할 수 없습니다.",
        "Cannot convert '{0}' to '{1}':{NL}{2}": "'{0}'을(를) '{1}'(으)로 변환할 수 없습니다. {NL}{2}",
        "Expected var, class, interface, or module.": "변수, 클래스, 인터페이스 또는 모듈이 필요합니다.",
        "Operator '{0}' cannot be applied to type '{1}'.": "'{0}' 연산자를 '{1}' 형식에 적용할 수 없습니다.",
        "Getter '{0}' already declared.": "Getter '{0}'이(가) 이미 선언되었습니다.",
        "Setter '{0}' already declared.": "Setter '{0}'이(가) 이미 선언되었습니다.",
        "Exported class '{0}' extends private class '{1}'.": "내보낸 클래스 '{0}'이(가) private 클래스 '{1}'을(를) 확장합니다.",
        "Exported class '{0}' implements private interface '{1}'.": "내보낸 클래스 '{0}'이(가) private 인터페이스 '{1}'을(를) 구현합니다.",
        "Exported interface '{0}' extends private interface '{1}'.": "내보낸 인터페이스 '{0}'이(가) private 인터페이스 '{1}'을(를) 확장합니다.",
        "Exported class '{0}' extends class from inaccessible module {1}.": "내보낸 클래스 '{0}'이(가) 액세스할 수 없는 모듈 {1}의 클래스를 확장합니다.",
        "Exported class '{0}' implements interface from inaccessible module {1}.": "내보낸 클래스 '{0}'이(가) 액세스할 수 없는 모듈 {1}의 인터페이스를 구현합니다.",
        "Exported interface '{0}' extends interface from inaccessible module {1}.": "내보낸 인터페이스 '{0}'이(가) 액세스할 수 없는 모듈 {1}의 인터페이스를 확장합니다.",
        "Public static property '{0}' of exported class has or is using private type '{1}'.": "내보낸 클래스의 공용 정적 속성 '{0}'이(가) 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Public property '{0}' of exported class has or is using private type '{1}'.": "내보낸 클래스의 공용 속성 '{0}'이(가) 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Property '{0}' of exported interface has or is using private type '{1}'.": "내보낸 인터페이스의 '{0}' 속성이 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Exported variable '{0}' has or is using private type '{1}'.": "내보낸 변수 '{0}'이(가) private 형식 '{1}'을(를) 가지고 있거나 사용하고 있습니다.",
        "Public static property '{0}' of exported class is using inaccessible module {1}.": "내보낸 클래스의 공용 정적 속성 '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Public property '{0}' of exported class is using inaccessible module {1}.": "내보낸 클래스의 공용 속성 '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Property '{0}' of exported interface is using inaccessible module {1}.": "내보낸 인터페이스의 '{0}' 속성이 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Exported variable '{0}' is using inaccessible module {1}.": "내보낸 변수 '{0}'이(가) 액세스할 수 없는 모듈 '{1}'을(를) 사용하고 있습니다.",
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": "내보낸 클래스에 있는 생성자의 '{0}' 매개 변수가 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": "내보낸 클래스에 있는 공용 정적 속성 setter의 '{0}' 매개 변수가 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": "내보낸 클래스에 있는 공용 속성 setter의 '{0}' 매개 변수가 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "내보낸 인터페이스에 있는 생성자 시그니처의 '{0}' 매개 변수가 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "내보낸 인터페이스에 있는 호출 시그니처의 '{0}' 매개 변수가 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": "내보낸 클래스에 있는 공용 정적 메서드의 '{0}' 매개 변수가 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": "내보낸 클래스에 있는 공용 메서드의 '{0}' 매개 변수가 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": "내보낸 인터페이스에 있는 메서드의 '{0}' 매개 변수가 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of exported function has or is using private type '{1}'.": "내보낸 함수의 '{0}' 매개 변수가 전용 형식 '{1}'을(를) 가지고 있거나 사용 중입니다.",
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": "내보낸 클래스에 있는 생성자의 '{0}' 매개 변수가 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": "내보낸 클래스에 있는 공용 정적 속성 setter의 '{0}' 매개 변수가 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": "내보낸 클래스에 있는 공용 속성 setter의 '{0}' 매개 변수가 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "내보낸 인터페이스에 있는 생성자 시그니처의 '{0}' 매개 변수가 액세스할 수 없는 {1} 모듈을 사용 중입니다.",
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": "내보낸 인터페이스에 있는 호출 시그니처의 '{0}' 매개 변수가 액세스할 수 없는 {1} 모듈을 사용 중입니다.",
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": "내보낸 클래스에 있는 공용 정적 메서드의 '{0}' 매개 변수가 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": "내보낸 클래스에 있는 공용 메서드의 '{0}' 매개 변수가 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": "내보낸 인터페이스에 있는 메서드의 '{0}' 매개 변수가 액세스할 수 없는 {1} 모듈을 사용 중입니다.",
        "Parameter '{0}' of exported function is using inaccessible module {1}.": "내보낸 함수의 '{0}' 매개 변수가 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Return type of public static property getter from exported class has or is using private type '{0}'.": "내보낸 클래스에 있는 공용 정적 속성 getter의 반환 형식이 전용 형식 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of public property getter from exported class has or is using private type '{0}'.": "내보낸 클래스에 있는 공용 속성 getter의 반환 형식이 전용 형식 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": "내보낸 인터페이스에 있는 생성자 시그니처의 반환 형식이 전용 형식 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of call signature from exported interface has or is using private type '{0}'.": "내보낸 인터페이스에 있는 호출 시그니처의 반환 형식이 전용 형식 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of index signature from exported interface has or is using private type '{0}'.": "내보낸 인터페이스에 있는 인덱스 시그니처의 반환 형식이 전용 형식 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of public static method from exported class has or is using private type '{0}'.": "내보낸 클래스에 있는 공용 정적 메서드의 반환 형식이 전용 형식 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of public method from exported class has or is using private type '{0}'.": "내보낸 클래스에 있는 공용 메서드의 반환 형식이 전용 형식 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of method from exported interface has or is using private type '{0}'.": "내보낸 인터페이스에 있는 메서드의 반환 형식이 전용 형식 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of exported function has or is using private type '{0}'.": "내보낸 함수의 반환 형식이 전용 형식 '{0}'을(를) 가지고 있거나 사용 중입니다.",
        "Return type of public static property getter from exported class is using inaccessible module {0}.": "내보낸 클래스에 있는 공용 정적 속성 getter의 반환 형식이 액세스할 수 없는 모듈 {0}을(를) 사용 중입니다.",
        "Return type of public property getter from exported class is using inaccessible module {0}.": "내보낸 클래스에 있는 공용 속성 getter의 반환 형식이 액세스할 수 없는 모듈 {0}을(를) 사용 중입니다.",
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": "내보낸 인터페이스에 있는 생성자 시그니처의 반환 형식이 액세스할 수 없는 모듈 {0}을(를) 사용 중입니다.",
        "Return type of call signature from exported interface is using inaccessible module {0}.": "내보낸 인터페이스에 있는 호출 시그니처의 반환 형식이 액세스할 수 없는 모듈 {0}을(를) 사용 중입니다.",
        "Return type of index signature from exported interface is using inaccessible module {0}.": "내보낸 인터페이스에 있는 인덱스 시그니처의 반환 형식이 액세스할 수 없는 모듈 {0}을(를) 사용 중입니다.",
        "Return type of public static method from exported class is using inaccessible module {0}.": "내보낸 클래스에 있는 공용 정적 메서드의 반환 형식이 액세스할 수 없는 모듈 {0}을(를) 사용 중입니다.",
        "Return type of public method from exported class is using inaccessible module {0}.": "내보낸 클래스에 있는 공용 메서드의 반환 형식이 액세스할 수 없는 모듈 {0}을(를) 사용 중입니다.",
        "Return type of method from exported interface is using inaccessible module {0}.": "내보낸 인터페이스에 있는 메서드의 반환 형식이 액세스할 수 없는 모듈 {0}을(를) 사용 중입니다.",
        "Return type of exported function is using inaccessible module {0}.": "내보낸 함수의 반환 형식이 액세스할 수 없는 모듈 {0}을(를) 사용 중입니다.",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "배열을 만드는 데 'new T[]'를 사용할 수 없습니다. 대신 'new Array<T>()'를 사용하십시오.",
        "A parameter list must follow a generic type argument list. '(' expected.": "매개 변수 목록은 제네릭 형식 인수 목록 뒤에 와야 합니다. '('가 필요합니다.",
        "Multiple constructor implementations are not allowed.": "여러 생성자 구현은 허용되지 않습니다.",
        "Unable to resolve external module '{0}'.": "외부 모듈 '{0}'을(를) 확인할 수 없습니다.",
        "Module cannot be aliased to a non-module type.": "모듈 별칭을 모듈이 아닌 형식으로 지정할 수 없습니다.",
        "A class may only extend another class.": "클래스는 다른 클래스만 확장할 수 있습니다.",
        "A class may only implement another class or interface.": "클래스는 다른 클래스나 인터페이스만 구현할 수 있습니다.",
        "An interface may only extend another class or interface.": "인터페이스는 다른 클래스나 인터페이스만 확장할 수 있습니다.",
        "Unable to resolve type.": "형식을 확인할 수 없습니다.",
        "Unable to resolve type of '{0}'.": "'{0}'의 형식을 확인할 수 없습니다.",
        "Unable to resolve type parameter constraint.": "형식 매개 변수 제약 조건을 확인할 수 없습니다.",
        "Type parameter constraint cannot be a primitive type.": "형식 매개 변수 제약 조건은 기본 형식이 될 수 없습니다.",
        "Supplied parameters do not match any signature of call target.": "제공된 매개 변수가 호출 대상의 시그니처와 일치하지 않습니다.",
        "Supplied parameters do not match any signature of call target:{NL}{0}": "제공된 매개 변수가 호출 대상의 시그니처와 일치하지 않습니다. {NL}{0}",
        "Invalid 'new' expression.": "잘못된 'new' 식입니다.",
        "Call signatures used in a 'new' expression must have a 'void' return type.": "'new' 식에 사용된 호출 시그니처에 'void' 반환 형식이 필요합니다.",
        "Could not select overload for 'new' expression.": "'new' 식의 오버로드를 선택할 수 없습니다.",
        "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": "'{0}' 형식이 형식 매개 변수 '{2}'에 대한 '{1}' 제약 조건을 만족하지 않습니다.",
        "Could not select overload for 'call' expression.": "'call' 식의 오버로드를 선택할 수 없습니다.",
        "Cannot invoke an expression whose type lacks a call signature.": "형식에 호출 시그니처가 없는 식을 호출할 수 없습니다.",
        "Calls to 'super' are only valid inside a class.": "클래스 안에서만 'super' 호출이 유효합니다.",
        "Generic type '{0}' requires {1} type argument(s).": "제네릭 형식 '{0}'에서 {1} 형식 인수를 반환합니다.",
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": "배열 리터럴 형식을 확인할 수 없습니다. 배열 요소에 가장 적합한 공용 형식을 찾을 수 없습니다.",
        "Could not find enclosing symbol for dotted name '{0}'.": "점 구분 이름 '{0}'의 구분 기호를 찾을 수 없습니다.",
        "The property '{0}' does not exist on value of type '{1}'.": "'{0}' 속성이 '{1}' 형식의 값에 없습니다.",
        "Could not find symbol '{0}'.": "'{0}' 기호를 찾을 수 없습니다.",
        "'get' and 'set' accessor must have the same type.": "'get' 및 'set' 접근자의 형식이 같아야 합니다.",
        "'this' cannot be referenced in current location.": "현재 위치에서 'this'를 참조할 수 없습니다.",
        "Static members cannot reference class type parameters.": "정적 멤버는 클래스 형식 매개 변수를 참조할 수 없습니다.",
        "Class '{0}' is recursively referenced as a base type of itself.": "'{0}' 클래스가 자체 기본 형식으로서 재귀적으로 참조됩니다.",
        "Interface '{0}' is recursively referenced as a base type of itself.": "'{0}' 인터페이스가 자체 기본 형식으로서 재귀적으로 참조됩니다.",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "'super' 속성 액세스는 생성자, 멤버 함수 또는 파생된 클래스의 멤버 접근자에서만 허용됩니다.",
        "'super' cannot be referenced in non-derived classes.": "파생되지 않은 클래스에서 'super'를 참조할 수 없습니다.",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "클래스에 초기화된 속성이 있거나 매개 변수 속성이 있으면 'super' 호출이 생성자에서 첫 번째 문이어야 합니다.",
        "Constructors for derived classes must contain a 'super' call.": "파생 클래스의 생성자는 'super' 호출을 포함해야 합니다.",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "생성자 밖이나 생성자 내부에 중첩된 함수에서는 Super 호출이 허용되지 않습니다.",
        "'{0}.{1}' is inaccessible.": "'{0}.{1}'에 액세스할 수 없습니다.",
        "'this' cannot be referenced within module bodies.": "모듈 본문 내에서 'this'를 참조할 수 없습니다.",
        "Invalid '+' expression - types not known to support the addition operator.": "잘못된 '+' 식 - 추가 연산자를 지원한다고 알려진 형식이 아닙니다.",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "산술 연산 오른쪽은 'any', 'number' 또는 열거형 형식이어야 합니다.",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "산술 연산 왼쪽은 'any', 'number' 또는 열거형 형식이어야 합니다.",
        "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": "단항 산술 연산 피연산자의 형식은 'any', 'number' 또는 열거형 형식이어야 합니다.",
        "Variable declarations of a 'for' statement cannot use a type annotation.": "'for' 문의 변수 선언에는 형식 주석을 사용할 수 없습니다.",
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": "'for' 문의 변수 선언은 'string' 또는 'any' 형식이어야 합니다.",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "'for...in' 문 오른쪽은 'any' 형식, 개체 형식 또는 형식 매개 변수여야 합니다.",
        "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": "'in' 식의 왼쪽은 'any', 'string' 또는 'number' 형식이어야 합니다.",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": "'in' 식 왼쪽은 'any' 형식, 개체 형식 또는 형식 매개 변수여야 합니다.",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "'instanceof' 식 왼쪽은 'any' 형식, 개체 형식 또는 형식 매개 변수여야 합니다.",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "'instanceof' 식 오른쪽은 'any' 형식이거나 'Function' 인터페이스 형식에 할당할 수 있는 형식이어야 합니다.",
        "Setters cannot return a value.": "Setter가 값을 반환할 수 없습니다.",
        "Tried to query type of uninitialized module '{0}'.": "초기화되지 않은 모듈 '{0}'의 형식을 쿼리하려고 했습니다.",
        "Tried to set variable type to uninitialized module type '{0}'.": "변수 형식을 초기화되지 않은 모듈 형식 '{0}'(으)로 설정하려고 했습니다.",
        "Type '{0}' does not have type parameters.": "형식 '{0}'에 형식 매개 변수가 없습니다.",
        "Getters must return a value.": "Getter는 값을 반환해야 합니다.",
        "Getter and setter accessors do not agree in visibility.": "Getter 및 Setter 접근자의 표시 유형이 다릅니다.",
        "Invalid left-hand side of assignment expression.": "할당 식 왼쪽이 잘못되었습니다.",
        "Function declared a non-void return type, but has no return expression.": "함수가 void가 아닌 반환 형식을 선언했지만 반환 식이 없습니다.",
        "Cannot resolve return type reference.": "반환 형식 참조를 확인할 수 없습니다.",
        "Constructors cannot have a return type of 'void'.": "생성자는 'void' 반환 형식을 가질 수 없습니다.",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "후속 변수 선언에 같은 형식이 있어야 합니다.  '{0}' 변수가 '{1}' 형식이어야 하는데 여기에는 '{2}' 형식이 있습니다.",
        "All symbols within a with block will be resolved to 'any'.": "with 블록 안의 모든 기호는 'any'로 확인됩니다.",
        "Import declarations in an internal module cannot reference an external module.": "내부 모듈의 Import 선언은 외부 모듈을 참조할 수 없습니다.",
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": "{0} 클래스는 {1} 인터페이스를 선언하지만 구현하지는 않습니다. {NL}{2}",
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": "{0} 클래스가 {1} 클래스를 인터페이스로 선언하지만 구현하지는 않습니다. {NL}{2}",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "증가 연산자 또는 감소 연산자의 피연산자는 변수, 속성 또는 인덱서여야 합니다.",
        "'this' cannot be referenced in static initializers in a class body.": "클래스 본문의 정적 이니셜라이저에서 'this'를 참조할 수 없습니다.",
        "Class '{0}' cannot extend class '{1}':{NL}{2}": "'{0}' 클래스는 '{1}' 클래스를 확장할 수 없습니다. {NL}{2}",
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": "'{0}' 인터페이스는 '{1}' 클래스를 확장할 수 없습니다. {NL}{2}",
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": "'{0}' 인터페이스는 '{1}' 인터페이스를 확장할 수 없습니다. {NL}{2}",
        "Duplicate overload signature for '{0}'.": "'{0}'의 오버로드 시그니처가 중복되었습니다.",
        "Duplicate constructor overload signature.": "생성자 오버로드 시그니처가 중복되었습니다.",
        "Duplicate overload call signature.": "오버로드 호출 시그니처가 중복되었습니다.",
        "Duplicate overload construct signature.": "오버로드 구문 시그니처가 중복되었습니다.",
        "Overload signature is not compatible with function definition.": "오버로드 시그니처가 함수 정의와 호환되지 않습니다.",
        "Overload signature is not compatible with function definition:{NL}{0}": "오버로드 시그니처가 함수 정의와 호환되지 않습니다. {NL}{0}",
        "Overload signatures must all be public or private.": "오버로드 시그니처는 모두 공용이거나 개인이어야 합니다.",
        "Overload signatures must all be exported or not exported.": "오버로드 시그니처는 모두 내보내거나 모두 내보내지 않아야 합니다.",
        "Overload signatures must all be ambient or non-ambient.": "오버로드 시그니처는 모두 앰비언트이거나 앰비언트가 아니어야 합니다.",
        "Overload signatures must all be optional or required.": "오버로드 시그니처는 모두 선택 사항이거나 필수 사항이어야 합니다.",
        "Specialized overload signature is not assignable to any non-specialized signature.": "특수화된 오버로드 시그니처는 특수화되지 않은 시그니처에 할당할 수 없습니다.",
        "'this' cannot be referenced in constructor arguments.": "생성자 인수에서 'this'를 참조할 수 없습니다.",
        "Instance member cannot be accessed off a class.": "클래스에서 인스턴스 멤버에 액세스할 수 없습니다.",
        "Untyped function calls may not accept type arguments.": "형식화되지 않은 함수 호출에는 형식 인수를 사용할 수 없습니다.",
        "Non-generic functions may not accept type arguments.": "제네릭이 아닌 함수에는 형식 인수를 사용할 수 없습니다.",
        "A generic type may not reference itself with a wrapped form of its own type parameters.": "제네릭 형식은 래핑된 형태의 형식 매개 변수로 자신을 참조할 수 없습니다.",
        "Rest parameters must be array types.": "Rest 매개 변수가 배열 형식이어야 합니다.",
        "Overload signature implementation cannot use specialized type.": "오버로드 시그니처 구현에 특수화된 형식을 사용할 수 없습니다.",
        "Export assignments may only be used at the top-level of external modules.": "할당 내보내기는 외부 모듈의 최상위에서만 사용할 수 있습니다.",
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": "외부 할당은 변수, 함수, 클래스, 인터페이스, 열거형 및 내부 모듈에서만 수행할 수 있습니다.",
        "Only public methods of the base class are accessible via the 'super' keyword.": "기본 클래스의 공용 메서드만 'super' 키워드를 통해 액세스할 수 있습니다.",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.": "숫자 인덱서 형식 '{0}'은(는) 문자열 인덱서 형식 '{1}'에 할당할 수 있어야 합니다.",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}": "숫자 인덱서 형식 '{0}'은(는) 문자열 인덱서 형식 '{1}':{NL}{2}에 할당할 수 있어야 합니다.",
        "All numerically named properties must be assignable to numeric indexer type '{0}'.": "숫자로 명명된 모든 속성은 숫자 인덱서 형식 '{0}'에 할당할 수 있어야 합니다.",
        "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}": "숫자로 명명된 모든 속성은 숫자 인덱서 형식 '{0}':{NL}:{1}에 할당할 수 있어야 합니다.",
        "All named properties must be assignable to string indexer type '{0}'.": "명명된 모든 속성은 문자열 인덱서 형식 '{0}'에 할당할 수 있어야 합니다.",
        "All named properties must be assignable to string indexer type '{0}':{NL}{1}": "명명된 모든 속성은 문자열 인덱서 형식 '{0}':{NL}{1}에 할당할 수 있어야 합니다.",
        "Generic type references must include all type arguments.": "제네릭 형식 참조에 모든 형식 인수가 포함되어야 합니다.",
        "Default arguments are only allowed in implementation.": "기본 인수는 구현에서만 허용됩니다.",
        "Overloads cannot differ only by return type.": "오버로드는 반환 형식 이외의 것도 달라야 합니다.",
        "Function expression declared a non-void return type, but has no return expression.": "함수 식이 void가 아닌 반환 형식을 선언했지만 반환 식이 없습니다.",
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": "내부 모듈의 식별자를 참조하는 Import 선언은 변수, 함수, 클래스, 인터페이스, 열거형 및 내부 모듈을 사용해야만 실행할 수 있습니다.",
        "Could not find symbol '{0}' in module '{1}'.": "'{1}' 모듈에서 '{0}' 기호를 찾을 수 없습니다.",
        "Unable to resolve module reference '{0}'.": "모듈 참조 '{0}'을(를) 확인할 수 없습니다.",
        "Could not find module '{0}' in module '{1}'.": "'{1}' 모듈에서 '{0}' 모듈을 찾을 수 없습니다.",
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": "내보낸 Import 선언 '{0}'에 전용 형식 '{1}'을(를) 가지고 있거나 사용하고 있는 형식이 지정된 값이 할당되어 있습니다.",
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": "내보낸 Import 선언 '{0}'에 액세스할 수 없는 '{1}' 모듈을 사용하고 있는 형식이 지정된 값이 할당되어 있습니다.",
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": "내보낸 Import 선언 '{0}'에 전용 형식 '{1}'을(를) 가지고 있거나 사용하고 있는 형식이 할당되어 있습니다.",
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": "내보낸 Import 선언 '{0}'에 액세스할 수 없는 '{1}' 모듈을 사용하고 있는 형식이 할당되어 있습니다.",
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": "내보낸 Import 선언 '{0}'에 액세스할 수 없는 '{1}' 모듈이거나 해당 모듈을 사용하고 있는 컨테이너가 할당되어 있습니다.",
        "Type name '{0}' in extends clause does not reference constructor function for '{1}'.": "확장 절의 형식 이름 '{0}'은(는) '{1}'에 대한 생성자 함수를 참조하지 않습니다.",
        "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": "가져오기 선언의 내부 모듈 참조 '{0}'은(는) '{1}'에 대한 모듈 인스턴스를 참조하지 않습니다.",
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": "'{0}' 모듈은 다른 파일 '{2}'에 있는 '{1}'의 이전 선언과 병합될 수 없습니다.",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": "인터페이스 '{0}'은(는) '{1}' 및 '{2}':{NL}{3} 형식을 동시에 확장할 수 없습니다.",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "매개 변수 '{0}'의 이니셜라이저는 그 다음에 선언된 식별자 '{1}'을(를) 참조할 수 없습니다.",
        "Ambient external module declaration cannot be reopened.": "앰비언트 외부 모듈 선언은 다시 열 수 없습니다.",
        "All declarations of merged declaration '{0}' must be exported or not exported.": "병합된 선언 '{0}'의 모든 선언을 내보내거나 모두 내보내지 않아야 합니다.",
        "'super' cannot be referenced in constructor arguments.": "'super'는 생성자 인수에서 참조할 수 없습니다.",
        "Return type of constructor signature must be assignable to the instance type of the class.": "생성자 시그니처의 반환 형식은 클래스의 인스턴스 형식에 할당할 수 있어야 합니다.",
        "Ambient external module declaration must be defined in global context.": "앰비언트 외부 모듈 선언은 전역 컨텍스트에서 정의해야 합니다.",
        "Ambient external module declaration cannot specify relative module name.": "앰비언트 외부 모듈 선언은 상대적 모듈 이름을 지정할 수 없습니다.",
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": "앰비언트 외부 모듈 선언의 가져오기 선언은 상대적 외부 모듈 이름을 통해 외부 모듈을 참조할 수 없습니다.",
        "Could not find the best common type of types of all return statement expressions.": "모든 반환 문 식의 형식 중 가장 적합한 공용 형식을 찾을 수 없습니다.",
        "Import declaration cannot refer to external module reference when --noResolve option is set.": "noResolve 옵션이 설정되었을 때는 가져오기 선언이 외부 모듈 참조를 참조할 수 없습니다.",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "중복 식별자 '_this'입니다. 컴파일러는 변수 선언 '_this'를 사용해서 'this' 참조를 캡처합니다.",
        "'continue' statement can only be used within an enclosing iteration statement.": "'continue' 문은 이 문을 둘러싼 반복 문 내에서만 사용할 수 있습니다.",
        "'break' statement can only be used within an enclosing iteration or switch statement.": "'break' 문은 이 문을 둘러싼 반복 문 또는 switch 문 내에서만 사용할 수 있습니다.",
        "Jump target not found.": "점프 대상을 찾을 수 없습니다.",
        "Jump target cannot cross function boundary.": "점프 대상은 함수 경계를 벗어날 수 없습니다.",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "중복 식별자 '_super'입니다. 컴파일러는 '_super'를 사용해서 기본 클래스 참조를 캡처합니다.",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "컴파일러가 'this' 참조를 캡처하기 위해 사용하는 변수 선언 '_this'로 식이 확인됩니다.",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "컴파일러가 기본 클래스 참조를 캡처하기 위해 사용하는 '_super'로 식이 확인됩니다.",
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "내보낸 인터페이스의 생성자 시그니처에 대한 TypeParameter '{0}'에 개인 형식 '{1}'이(가) 포함되었거나 이를 사용 중입니다.",
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "내보낸 인터페이스의 호출 시그니처에 대한 TypeParameter '{0}'에 개인 형식 '{1}'이(가) 포함되었거나 이를 사용 중입니다.",
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": "내보낸 클래스의 공용 정적 메서드에 대한 TypeParameter '{0}'에 개인 형식 '{1}'이(가) 포함되었거나 이를 사용 중입니다.",
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": "내보낸 클래스의 공용 메서드에 대한 TypeParameter '{0}'에 개인 형식 '{1}'이(가) 포함되었거나 이를 사용 중입니다.",
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": "내보낸 인터페이스의 메서드에 대한 TypeParameter '{0}'에 개인 형식 '{1}'이(가) 포함되었거나 이를 사용 중입니다.",
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": "내보낸 함수에 대한 TypeParameter '{0}'에 개인 형식 '{1}'이(가) 포함되었거나 이를 사용 중입니다.",
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "내보낸 인터페이스의 생성자 시그니처에 대한 TypeParameter '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": "내보낸 인터페이스의 호출 시그니처에 대한 TypeParameter '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": "내보낸 클래스의 공용 정적 메서드에 대한 TypeParameter '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": "내보낸 클래스의 공용 메서드에 대한 TypeParameter '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": "내보낸 인터페이스의 메서드에 대한 TypeParameter '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": "내보낸 함수에 대한 TypeParameter '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": "내보낸 클래스에 대한 TypeParameter '{0}'에 개인 형식 '{1}'이(가) 포함되었거나 이를 사용 중입니다.",
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": "내보낸 인터페이스에 대한 TypeParameter '{0}'에 개인 형식 '{1}'이(가) 포함되었거나 이를 사용 중입니다.",
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": "내보낸 클래스에 대한 TypeParameter '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": "내보낸 인터페이스에 대한 TypeParameter '{0}'이(가) 액세스할 수 없는 모듈 {1}을(를) 사용 중입니다.",
        "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": "중복 식별자 '_i'입니다. 컴파일러는 '_i'를 사용해서 rest 매개 변수를 초기화합니다.",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "중복 식별자 'arguments'입니다. 컴파일러는 'arguments'를 사용해서 rest 매개 변수를 초기화합니다.",
        "Type of conditional '{0}' must be identical to '{1}' or '{2}'.": "조건부 '{0}'의 형식은 '{1}' 또는 '{2}'과(와) 동일해야 합니다.",
        "Type of conditional '{0}' must be identical to '{1}', '{2}' or '{3}'.": "조건부 '{0}'의 형식은 '{1}', '{2}' 또는 '{3}'과(와) 동일해야 합니다.",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": "중복 식별자 '{0}'입니다. 컴파일러는 외부 모듈의 최상위 범위에 이름 '{1}'을(를) 예약합니다.",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "형식 매개 변수의 제약 조건은 동일 형식의 매개 변수 목록에서 형식 매개 변수를 참조할 수 없습니다.",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "인스턴스 멤버 변수 '{0}'의 이니셜라이저는 생성자에 선언된 식별자 '{1}'을(를) 참조할 수 없습니다.",
        "Parameter '{0}' cannot be referenced in its initializer.": "매개 변수 '{0}'은(는) 해당 이니셜라이저에서 참조할 수 없습니다.",
        "Duplicate string index signature.": "중복 문자열 인덱스 시그니처입니다.",
        "Duplicate number index signature.": "중복 숫자 인덱스 시그니처입니다.",
        "All declarations of an interface must have identical type parameters.": "인터페이스의 모든 선언에는 동일한 형식 매개 변수가 포함되어야 합니다.",
        "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.": "식이 컴파일러가 rest 매개 변수를 초기화하는 데 사용하는 변수 선언 '_i'로 확인됩니다.",
        "Type '{0}' is missing property '{1}' from type '{2}'.": "'{0}' 형식에 '{2}' 형식의 '{1}' 속성이 없습니다.",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": "'{1}' 및 '{2}' 형식을 가진 '{0}' 속성의 형식이 호환되지 않습니다.",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": "'{1}' 및 '{2}' 형식을 가진 '{0}' 속성의 형식이 호환되지 않습니다. {NL}{3}",
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "'{1}' 형식에 전용으로 정의된 '{0}' 속성이 '{2}' 형식에 공용으로 정의되었습니다.",
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "'{1}' 형식에 공용으로 정의된 '{0}' 속성이 '{2}' 형식에 전용으로 정의되었습니다.",
        "Types '{0}' and '{1}' define property '{2}' as private.": "'{0}' 및 '{1}' 형식이 '{2}' 속성을 전용으로 정의합니다.",
        "Call signatures of types '{0}' and '{1}' are incompatible.": "'{0}' 및 '{1}' 형식의 호출 시그니처가 호환되지 않습니다.",
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "'{0}' 및 '{1}' 형식의 호출 시그니처가 호환되지 않습니다. {NL}{2}",
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": "'{0}' 형식에 호출 시그니처가 필요한데 '{1}' 형식에 없습니다.",
        "Construct signatures of types '{0}' and '{1}' are incompatible.": "'{0}' 및 '{1}' 형식의 구문 시그니처가 호환되지 않습니다.",
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "'{0}' 및 '{1}' 형식의 구문 시그니처가 호환되지 않습니다. {NL}{2}",
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": "'{0}' 형식에 구문 시그니처가 필요한데 '{1}' 형식에 없습니다.",
        "Index signatures of types '{0}' and '{1}' are incompatible.": "'{0}' 및 '{1}' 형식의 인덱스 시그니처가 호환되지 않습니다.",
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "'{0}' 및 '{1}' 형식의 인덱스 시그니처가 호환되지 않습니다. {NL}{2}",
        "Call signature expects {0} or fewer parameters.": "호출 시그니처에 {0}개 이하의 매개 변수가 필요합니다.",
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": "'{0}' 형식을 '{2}' 형식의 {1} 인수에 적용할 수 없습니다.",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "'{0}' 클래스는 인스턴스 멤버 접근자 '{1}'을(를) 정의하지만 확장 클래스 '{2}'은(는) 이 접근자를 인스턴스 멤버 함수로 정의합니다.",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "'{0}' 클래스가 인스턴스 멤버 속성 '{1}'을(를) 정의하지만 확장 클래스 '{2}'은(는) 이 속성을 인스턴스 멤버 함수로 정의합니다.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "'{0}' 클래스가 인스턴스 멤버 함수 '{1}'을(를) 정의하지만 확장 클래스 '{2}'은(는) 이 함수를 인스턴스 멤버 접근자로 정의합니다.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "'{0}' 클래스가 인스턴스 멤버 함수 '{1}'을(를) 정의하지만 확장 클래스 '{2}'은(는) 이 함수를 인스턴스 멤버 속성으로 정의합니다.",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": "'{1}' 클래스 및 '{2}' 클래스의 정적 속성 '{0}'의 형식이 호환되지 않습니다.",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": "'{1}' 클래스 및 '{2}' 클래스의 정적 속성 '{0}'의 형식이 호환되지 않습니다. {NL}{3}",
        "Type reference cannot refer to container '{0}'.": "형식 참조가 '{0}' 컨테이너를 참조할 수 없습니다.",
        "Type reference must refer to type.": "형식 참조는 형식을 참조해야 합니다.",
        "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.": "다중 선언이 포함된 열거형에서는 하나의 선언만 첫 번째 열거형 요소에 대한 이니셜라이저를 생략할 수 있습니다.",
        " (+ {0} overload(s))": " (+ {0} 오버로드)",
        "Variable declaration cannot have the same name as an import declaration.": "변수 선언에는 가져오기 선언과 동일한 이름을 지정할 수 없습니다.",
        "Signature expected {0} type arguments, got {1} instead.": "시그니처에 {0} 형식 인수가 필요하지만 대신 {1}을(를) 가져왔습니다.",
        "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": "속성 '{0}'이(가) '{1}' 형식에서 선택 사항으로 정의되었지만 '{2}' 형식에서는 필수입니다.",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.": "무한 확장 형식 참조에서 시작되는 '{0}' 및 '{1}' 형식은 동일한 명명된 형식을 참조하지 않습니다.",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.": "무한 확장 형식 참조에서 시작되는 '{0}' 및 '{1}' 형식은 호환되지 않는 형식 인수를 포함합니다.",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}": "무한 확장 형식 참조에서 시작되는 '{0}' 및 '{1}' 형식은 호환되지 않는 형식 인수 {NL}{2}을(를) 포함합니다.",
        "Named properties '{0}' of types '{1}' and '{2}' are not identical.": "'{1}' 및 '{2}' 형식의 명명된 속성 '{0}'은(는) 동일하지 않습니다.",
        "Types of string indexer of types '{0}' and '{1}' are not identical.": "'{0}' 및 '{1}' 형식의 문자열 인덱서 형식이 동일하지 않습니다.",
        "Types of number indexer of types '{0}' and '{1}' are not identical.": "'{0}' 및 '{1}' 형식의 숫자 인덱서 형식이 동일하지 않습니다.",
        "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}": "형식 '{0}'의 숫자 인덱서 형식은 형식 '{1}'.{NL}{2}의 문자열 인덱서 형식에 할당할 수 없습니다.",
        "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}": "형식 '{1}'의 속성 형식 '{0}'은(는) 형식 '{2}'.{NL}{3}의 문자열 인덱서 형식에 할당할 수 없습니다.",
        "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}": "형식 '{1}'의 속성 형식 '{0}'은(는) 형식 '{2}'.{NL}{3}의 숫자 인덱서 형식에 할당할 수 없습니다.",
        "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "'{1}' 형식에서 전용으로 정의된 정적 속성 '{0}'이(가) '{2}' 형식에서는 공용으로 정의되었습니다.",
        "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "'{1}' 형식에서 공용으로 정의된 정적 속성 '{0}'이(가) '{2}' 형식에서는 전용으로 정의되었습니다.",
        "Types '{0}' and '{1}' define static property '{2}' as private.": "'{0}' 및 '{1}' 형식은 정적 속성 '{2}'을(를) 전용으로 정의합니다.",
        "Current host does not support '{0}' option.": "현재 호스트가 '{0}' 옵션을 지원하지 않습니다.",
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": "ECMAScript 대상 버전 '{0}'은(는) 지원되지 않습니다. 올바른 대상 버전인 '{1}'(기본값) 또는 '{2}'을(를) 지정하십시오.",
        "Module code generation '{0}' not supported.": "모듈 코드 생성 '{0}'은(는) 지원되지 않습니다.",
        "Could not find file: '{0}'.": "'{0}' 파일을 찾을 수 없습니다.",
        "A file cannot have a reference to itself.": "파일에 자신에 대한 참조를 포함할 수 없습니다.",
        "Cannot resolve referenced file: '{0}'.": "참조된 파일 '{0}'을(를) 확인할 수 없습니다.",
        "Cannot find the common subdirectory path for the input files.": "입력 파일의 공용 하위 디렉터리 경로를 찾을 수 없습니다.",
        "Emit Error: {0}.": "오류 내보내기: {0}.",
        "Cannot read file '{0}': {1}": "파일 '{0}'을(를) 읽을 수 없습니다. {1}",
        "Unsupported file encoding.": "지원되지 않는 파일 인코딩입니다.",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "로캘이 <language> 또는 <language>-<territory> 형식이어야 합니다. 예를 들어 '{0}' 또는 '{1}'입니다.",
        "Unsupported locale: '{0}'.": "지원되지 않는 로캘: '{0}'.",
        "Execution Failed.{NL}": "실행 실패. {NL}",
        "Invalid call to 'up'": "'up'에 대한 잘못된 호출",
        "Invalid call to 'down'": "'down'에 대한 잘못된 호출",
        "Base64 value '{0}' finished with a continuation bit.": "Base64 값 '{0}'이(가) 연속 비트로 종료되었습니다.",
        "Unknown option '{0}'": "알 수 없는 옵션 '{0}'",
        "Expected {0} arguments to message, got {1} instead.": "메시지에 {0} 인수가 필요하지만 대신 {1}을(를) 가져왔습니다.",
        "Expected the message '{0}' to have {1} arguments, but it had {2}": "{1} 인수가 있는 '{0}' 메시지가 필요한데 {2}이(가) 있습니다.",
        "Could not delete file '{0}'": "'{0}' 파일을 삭제할 수 없습니다.",
        "Could not create directory '{0}'": "'{0}' 디렉터리를 만들 수 없습니다.",
        "Error while executing file '{0}': ": "'{0}' 파일을 실행하는 동안 오류가 발생했습니다. ",
        "Cannot compile external modules unless the '--module' flag is provided.": "'--module' 플래그를 제공하지 않으면 외부 모듈을 컴파일할 수 없습니다.",
        "Option mapRoot cannot be specified without specifying sourcemap option.": "sourcemap 옵션을 지정하지 않고 mapRoot 옵션을 지정할 수 없습니다.",
        "Option sourceRoot cannot be specified without specifying sourcemap option.": "sourcemap 옵션을 지정하지 않고 sourceRoot 옵션을 지정할 수 없습니다.",
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": "sourcemap 옵션을 지정하지 않고 mapRoot 및 sourceRoot 옵션을 지정할 수 없습니다.",
        "Option '{0}' specified without '{1}'": "'{1}을(를) 사용하지 않고 '{0}' 옵션을 지정했습니다.",
        "'codepage' option not supported on current platform.": "현재 플랫폼에서는 'codepage' 옵션이 지원되지 않습니다.",
        "Concatenate and emit output to single file.": "출력을 연결하고 단일 파일로 내보냅니다.",
        "Generates corresponding {0} file.": "해당 {0} 파일을 생성합니다.",
        "Specifies the location where debugger should locate map files instead of generated locations.": "디버거가 생성된 위치 대신 맵 파일을 찾아야 하는 위치를 지정합니다.",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "디버거가 소스 위치 대신 TypeScript 파일을 찾아야 하는 위치를 지정합니다.",
        "Watch input files.": "조사식 입력 파일입니다.",
        "Redirect output structure to the directory.": "출력 구조를 디렉터리로 리디렉션합니다.",
        "Do not emit comments to output.": "주석을 출력에 내보내지 마십시오.",
        "Skip resolution and preprocessing.": "확인 및 전처리를 건너뜁니다.",
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": "ECMAScript 대상 버전인 '{0}'(기본값) 또는 '{1}'을(를) 지정하십시오.",
        "Specify module code generation: '{0}' or '{1}'": "모듈 코드 생성 '{0}' 또는 '{1}'을(를) 지정하십시오.",
        "Print this message.": "이 메시지를 출력합니다.",
        "Print the compiler's version: {0}": "컴파일러 버전 인쇄: {0}",
        "Allow use of deprecated '{0}' keyword when referencing an external module.": "더 이상 사용되지 않는 '{0}' 키워드는 외부 모듈을 참조할 때 사용이 허용됩니다.",
        "Specify locale for errors and messages. For example '{0}' or '{1}'": "오류 및 메시지의 로캘을 지정하십시오. 예를 들어 '{0}' 또는 '{1}'입니다.",
        "Syntax:   {0}": "구문:   {0}",
        "options": "옵션",
        "file1": "파일",
        "Examples:": "예:",
        "Options:": "옵션:",
        "Insert command line options and files from a file.": "파일에서 명령줄 옵션 및 파일을 삽입합니다.",
        "Version {0}": "버전 {0}",
        "Use the '{0}' flag to see options.": "옵션을 보려면 '{0}' 플래그를 사용하십시오.",
        "{NL}Recompiling ({0}):": "{NL}다시 컴파일하는 중({0}):",
        "STRING": "STRING",
        "KIND": "KIND",
        "file2": "파일",
        "VERSION": "버전",
        "LOCATION": "위치",
        "DIRECTORY": "디렉터리",
        "NUMBER": "수",
        "Specify the codepage to use when opening source files.": "소스 파일을 열 때 사용할 코드 페이지를 지정합니다.",
        "Additional locations:": "추가 위치:",
        "This version of the Javascript runtime does not support the '{0}' function.": "이 버전의 Javascript 런타임은 '{0}' 함수를 지원하지 않습니다.",
        "Unknown rule.": "알 수 없는 규칙입니다.",
        "Invalid line number ({0})": "잘못된 줄 번호({0})",
        "Warn on expressions and declarations with an implied 'any' type.": "암시된 'any' 형식이 있는 식 및 선언이 발생할 경우 경고 표시",
        "Variable '{0}' implicitly has an 'any' type.": "'{0}' 변수에 암시적으로 'any' 형식이 있습니다.",
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": "'{1}'의 '{0}' 매개 변수에 암시적으로 'any' 형식이 있습니다.",
        "Parameter '{0}' of function type implicitly has an 'any' type.": "함수 형식의 '{0}' 매개 변수에 암시적으로 'any' 형식이 있습니다.",
        "Member '{0}' of object type implicitly has an 'any' type.": "개체 형식의 '{0}' 멤버에 암시적으로 'any' 형식이 있습니다.",
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": "생성자 시그니처가 없는 'new' 식은 암시적으로 'any' 형식을 갖습니다.",
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": "반환 형식 주석이 없는 '{0}'에 암시적으로 'any' 반환 형식이 있습니다.",
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": "반환 형식 주석이 없는 함수 식에 암시적으로 'any' 반환 형식이 있습니다.",
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": "람다 함수의 '{0}' 매개 변수에 암시적으로 'any' 형식이 있습니다.",
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": "반환 형식 주석이 없는 생성자 시그니처에 암시적으로 'any' 반환 형식이 있습니다.",
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": "반환 형식 주석이 없는 람다 함수에 암시적으로 'any' 반환 형식이 있습니다.",
        "Array Literal implicitly has an 'any' type from widening.": "배열 리터럴에 암시적으로 확대의 'any' 형식이 있습니다.",
        "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": "'get' 접근자 및 'set' 접근자에 대한 매개 변수 형식 주석이 없는 '{0}'은(는) 암시적으로 'any' 형식을 갖습니다.",
        "Index signature of object type implicitly has an 'any' type.": "개체 형식의 인덱스 시그니처에는 암시적으로 'any' 형식이 포함됩니다.",
        "Object literal's property '{0}' implicitly has an 'any' type from widening.": "개체 리터럴의 속성 '{0}'에는 암시적으로 확대의 'any' 형식이 포함됩니다."
}