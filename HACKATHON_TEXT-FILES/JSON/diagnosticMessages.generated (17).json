{
        "error TS{0}: {1}": "错误 TS{0}: {1}",
        "warning TS{0}: {1}": "警告 TS{0}: {1}",
        "Unrecognized escape sequence.": "无法识别的转义序列。",
        "Unexpected character {0}.": "意外的字符 {0}。",
        "Missing close quote character.": "缺少右引号字符。",
        "Identifier expected.": "应为标识符。",
        "'{0}' keyword expected.": "应为“{0}”关键字。",
        "'{0}' expected.": "应为“{0}”。",
        "Identifier expected; '{0}' is a keyword.": "应为标识符；“{0}”是关键字。",
        "Automatic semicolon insertion not allowed.": "不允许自动插入分号。",
        "Unexpected token; '{0}' expected.": "意外的标记；应为“{0}”。",
        "Trailing separator not allowed.": "不允许使用尾随分隔符。",
        "'*/' expected.": "应为“*/”。",
        "'public' or 'private' modifier must precede 'static'.": "“public”或“private”修饰符必须位于“static”之前。",
        "Unexpected token.": "意外的标记。",
        "Catch clause parameter cannot have a type annotation.": "catch 子句参数不能具有类型批注。",
        "Rest parameter must be last in list.": "Rest 参数必须是列表中的最后一个参数。",
        "Parameter cannot have question mark and initializer.": "参数不能具有问号和初始值。",
        "Required parameter cannot follow optional parameter.": "必需参数不能位于可选参数之后。",
        "Index signatures cannot have rest parameters.": "索引签名不能具有 rest 参数。",
        "Index signature parameter cannot have accessibility modifiers.": "索引签名参数不能具有可访问性修饰符。",
        "Index signature parameter cannot have a question mark.": "索引签名参数不能具有问号。",
        "Index signature parameter cannot have an initializer.": "索引签名参数不能具有初始值。",
        "Index signature must have a type annotation.": "索引签名必须具有类型批注。",
        "Index signature parameter must have a type annotation.": "索引签名参数必须具有类型批注。",
        "Index signature parameter type must be 'string' or 'number'.": "索引签名参数类型必须为“string”或“number”。",
        "'extends' clause already seen.": "已看到“extends”子句。",
        "'extends' clause must precede 'implements' clause.": "“extends”子句必须位于“implements”子句之前。",
        "Classes can only extend a single class.": "类只能扩展一个类。",
        "'implements' clause already seen.": "已看到“implements”子句。",
        "Accessibility modifier already seen.": "已看到可访问性修饰符。",
        "'{0}' modifier must precede '{1}' modifier.": "“{0}”修饰符必须位于“{1}”修饰符之前。",
        "'{0}' modifier already seen.": "已看到“{0}”修饰符。",
        "'{0}' modifier cannot appear on a class element.": "“{0}”修饰符不能出现在类元素上。",
        "Interface declaration cannot have 'implements' clause.": "接口声明不能具有“implements”子句。",
        "'super' invocation cannot have type arguments.": "“super”调用不能具有类型参数。",
        "Only ambient modules can use quoted names.": "仅环境模块可使用带引号的名称。",
        "Statements are not allowed in ambient contexts.": "不允许在环境上下文中使用语句。",
        "Implementations are not allowed in ambient contexts.": "不允许在环境上下文中存在实现。",
        "'declare' modifier not allowed for code already in an ambient context.": "环境上下文中已有的代码不能使用“declare”修饰符。",
        "Initializers are not allowed in ambient contexts.": "不允许在环境上下文中使用初始值。",
        "Parameter property declarations can only be used in a non-ambient constructor declaration.": "只能在非环境构造函数声明中使用参数属性声明。",
        "Function implementation expected.": "应为函数实现。",
        "Constructor implementation expected.": "应为构造函数实现。",
        "Function overload name must be '{0}'.": "函数重载名称必须为“{0}”。",
        "'{0}' modifier cannot appear on a module element.": "“{0}”修饰符不能出现在模块元素上。",
        "'declare' modifier cannot appear on an interface declaration.": "“declare”修饰符不能出现在接口声明中。",
        "'declare' modifier required for top level element.": "顶级元素需要“declare”修饰符。",
        "Rest parameter cannot be optional.": "Rest 参数不能为可选参数。",
        "Rest parameter cannot have an initializer.": "Rest 参数不能具有初始值。",
        "'set' accessor must have one and only one parameter.": "“set”访问器必须有并且只能有一个参数。",
        "'set' accessor parameter cannot be optional.": "“set”访问器参数不能为可选参数。",
        "'set' accessor parameter cannot have an initializer.": "“set”访问器参数不能具有初始值。",
        "'set' accessor cannot have rest parameter.": "“set”访问器不能具有 rest 参数。",
        "'get' accessor cannot have parameters.": "“get”访问器不能具有参数。",
        "Modifiers cannot appear here.": "修饰符不能出现在此处。",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "访问器仅在面向 ECMAScript 5 和更高版本时可用。",
        "Class name cannot be '{0}'.": "类名称不能是“{0}”。",
        "Interface name cannot be '{0}'.": "接口名称不能是“{0}”。",
        "Enum name cannot be '{0}'.": "枚举名称不能为“{0}”。",
        "Module name cannot be '{0}'.": "模块名称不能是“{0}”。",
        "Enum member must have initializer.": "枚举成员必须具有初始值。",
        "Export assignment cannot be used in internal modules.": "不能在内部模块中使用导出分配。",
        "Export assignment not allowed in module with exported element.": "不允许在具有导出的元素的模块中分配导出。",
        "Module cannot have multiple export assignments.": "模块不能具有多个导出分配。",
        "Ambient enum elements can only have integer literal initializers.": "环境枚举元素只能具有整型文本初始值。",
        "module, class, interface, enum, import or statement": "模块、类、接口、枚举、导入或语句",
        "constructor, function, accessor or variable": "构造函数、函数、访问器或变量",
        "statement": "语句",
        "case or default clause": "用例或默认子句",
        "identifier": "标识符",
        "call, construct, index, property or function signature": "调用、构造、索引、属性或函数签名",
        "expression": "表达式",
        "type name": "类型名称",
        "property or accessor": "属性或访问器",
        "parameter": "参数",
        "type": "类型",
        "type parameter": "类型参数",
        "'declare' modifier not allowed on import declaration.": "导入声明中不允许使用“declare”修饰符。",
        "Function overload must be static.": "函数重载必须为静态。",
        "Function overload must not be static.": "函数重载不能是静态的。",
        "Parameter property declarations cannot be used in a constructor overload.": "不能在构造函数重载中使用参数属性声明。",
        "Invalid 'reference' directive syntax.": "“reference”指令语法无效。",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "当目标为 ECMAScript 5 和更高版本时，八进制文本不可用。",
        "Accessors are not allowed in ambient contexts.": "不允许在环境上下文中使用访问器。",
        "'{0}' modifier cannot appear on a constructor declaration.": "“{0}”修饰符不能出现在构造函数声明中。",
        "'{0}' modifier cannot appear on a parameter.": "“{0}”修饰符不能出现在参数中。",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "“for...in”语句中只允许一个变量声明。",
        "Type parameters cannot appear on a constructor declaration.": "类型参数不能出现在构造函数声明中。",
        "Type annotation cannot appear on a constructor declaration.": "类型注释不能出现在构造函数声明中。",
        "Duplicate identifier '{0}'.": "标识符“{0}”重复。",
        "The name '{0}' does not exist in the current scope.": "名称“{0}”在当前范围内不存在。",
        "The name '{0}' does not refer to a value.": "名称“{0}”没有引用值。",
        "'super' can only be used inside a class instance method.": "“super”只能在类实例方法中使用。",
        "The left-hand side of an assignment expression must be a variable, property or indexer.": "赋值表达式左侧必须是变量、属性或索引器。",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "类型“{0}”的值不可调用。是否希望包括“new”?",
        "Value of type '{0}' is not callable.": "类型“{0}”的值不可调用。",
        "Value of type '{0}' is not newable.": "类型“{0}”的值不可续订。",
        "Value of type '{0}' is not indexable by type '{1}'.": "类型“{0}”的值无法按类型“{1}”建立索引。",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "运算符“{0}”不能应用于类型“{1}”和“{2}”。",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": "运算符“{0}”不能应用于类型“{1}”和“{2}”: {3}",
        "Cannot convert '{0}' to '{1}'.": "无法将“{0}”转换为“{1}”。",
        "Cannot convert '{0}' to '{1}':{NL}{2}": "无法将“{0}”转换为“{1}”: {NL}{2}",
        "Expected var, class, interface, or module.": "应为变量、类、接口或模块。",
        "Operator '{0}' cannot be applied to type '{1}'.": "运算符“{0}”不能应用于类型“{1}”。",
        "Getter '{0}' already declared.": "已声明 Getter“{0}”。",
        "Setter '{0}' already declared.": "已声明 Setter“{0}”。",
        "Exported class '{0}' extends private class '{1}'.": "导出的类“{0}”扩展私有类“{1}”。",
        "Exported class '{0}' implements private interface '{1}'.": "导出的类“{0}”实现私有接口“{1}”。",
        "Exported interface '{0}' extends private interface '{1}'.": "导出的接口“{0}”扩展私有接口“{1}”。",
        "Exported class '{0}' extends class from inaccessible module {1}.": "导出的类“{0}”从无法访问的模块 {1} 扩展类。",
        "Exported class '{0}' implements interface from inaccessible module {1}.": "导出的类“{0}”从无法访问的模块 {1} 实现接口。",
        "Exported interface '{0}' extends interface from inaccessible module {1}.": "导出的接口“{0}”从无法访问的模块 {1} 扩展接口。",
        "Public static property '{0}' of exported class has or is using private type '{1}'.": "导出类的公共静态属性“{0}”当前具有或使用私有类型“{1}”。",
        "Public property '{0}' of exported class has or is using private type '{1}'.": "导出类的公共属性“{0}”当前具有或使用私有类型“{1}”。",
        "Property '{0}' of exported interface has or is using private type '{1}'.": "导出接口的属性“{0}”当前具有或使用私有类型“{1}”。",
        "Exported variable '{0}' has or is using private type '{1}'.": "导出的变量“{0}”当前具有或使用私有类型“{1}”。",
        "Public static property '{0}' of exported class is using inaccessible module {1}.": "导出类的公共静态属性“{0}”当前使用无法访问的模块 {1}。",
        "Public property '{0}' of exported class is using inaccessible module {1}.": "导出类的公共属性“{0}”当前使用无法访问的模块 {1}。",
        "Property '{0}' of exported interface is using inaccessible module {1}.": "导出接口的属性“{0}”当前使用无法访问的模块 {1}。",
        "Exported variable '{0}' is using inaccessible module {1}.": "导出的变量“{0}”当前使用无法访问的模块 {1}。",
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": "导出类中的构造函数的参数“{0}”当前具有或使用私有类型“{1}”。",
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": "导出类中的公共静态属性的参数“{0}”当前具有或使用私有类型“{1}”。",
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": "导出类中的公共属性 setter 的参数“{0}”当前具有或使用私有类型“{1}”。",
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "导出接口中的构造函数签名的参数“{0}”当前具有或使用私有类型“{1}”。",
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "导出接口中的调用签名的参数“{0}”当前具有或使用私有类型“{1}”。",
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": "导出类中的公共静态方法的参数“{0}”当前具有或使用私有类型“{1}”。",
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": "导出类中的公共方法的参数“{0}”当前具有或使用私有类型“{1}”。",
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": "导出接口中的方法的参数“{0}”当前具有或使用私有类型“{1}”。",
        "Parameter '{0}' of exported function has or is using private type '{1}'.": "导出函数的参数“{0}”当前具有或使用私有类型“{1}”。",
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": "导出类中的构造函数的参数“{0}”当前使用无法访问的模块 {1}。",
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": "导出类中的公共静态属性 setter 的参数“{0}”当前使用无法访问的模块 {1}。",
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": "导出类中的公共属性 setter 的参数“{0}”当前使用无法访问的模块 {1}。",
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "导出接口中的构造函数签名的参数“{0}”当前使用无法访问的模块 {1}。",
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": "导出接口中的调用签名的参数“{0}”当前使用无法访问的模块 {1}。",
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": "导出类中的公共静态方法的参数“{0}”当前使用无法访问的模块 {1}。",
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": "导出类中的公共方法的参数“{0}”当前使用无法访问的模块 {1}。",
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": "导出接口中的方法的参数“{0}”当前使用无法访问的模块 {1}。",
        "Parameter '{0}' of exported function is using inaccessible module {1}.": "导出函数的参数“{0}”当前使用无法访问的模块 {1}。",
        "Return type of public static property getter from exported class has or is using private type '{0}'.": "导出类中的公共静态属性 getter 的返回类型当前具有或使用私有类型“{0}”。",
        "Return type of public property getter from exported class has or is using private type '{0}'.": "导出类中的公共属性 getter 的返回类型当前具有或使用私有类型“{0}”。",
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": "导出接口中的构造函数签名的返回类型当前具有或使用私有类型“{0}”。",
        "Return type of call signature from exported interface has or is using private type '{0}'.": "导出接口中的调用签名的返回类型当前具有或使用私有类型“{0}”。",
        "Return type of index signature from exported interface has or is using private type '{0}'.": "导出接口中的索引签名的返回类型当前具有或使用私有类型“{0}”。",
        "Return type of public static method from exported class has or is using private type '{0}'.": "导出类中的公共静态方法的返回类型当前具有或使用私有类型“{0}”。",
        "Return type of public method from exported class has or is using private type '{0}'.": "导出类中的公共方法的返回类型当前具有或使用私有类型“{0}”。",
        "Return type of method from exported interface has or is using private type '{0}'.": "导出接口中的方法的返回类型当前具有或使用私有类型“{0}”。",
        "Return type of exported function has or is using private type '{0}'.": "导出函数的返回类型当前具有或使用私有类型“{0}”。",
        "Return type of public static property getter from exported class is using inaccessible module {0}.": "导出类中的公共静态属性 getter 的返回类型当前使用无法访问的模块 {0}。",
        "Return type of public property getter from exported class is using inaccessible module {0}.": "导出类中的公共属性 getter 的返回类型当前使用无法访问的模块 {0}。",
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": "导出接口中的构造函数签名的返回类型当前使用无法访问的模块 {0}。",
        "Return type of call signature from exported interface is using inaccessible module {0}.": "导出接口中的调用签名的返回类型当前使用无法访问的模块 {0}。",
        "Return type of index signature from exported interface is using inaccessible module {0}.": "导出接口中的索引签名的返回类型当前使用无法访问的模块 {0}。",
        "Return type of public static method from exported class is using inaccessible module {0}.": "导出类中的公共静态方法的返回类型当前使用无法访问的模块 {0}。",
        "Return type of public method from exported class is using inaccessible module {0}.": "导出类中的公共方法的返回类型当前使用无法访问的模块 {0}。",
        "Return type of method from exported interface is using inaccessible module {0}.": "导出接口中的方法的返回类型当前使用无法访问的模块 {0}。",
        "Return type of exported function is using inaccessible module {0}.": "导出函数的返回类型当前使用无法访问的模块 {0}。",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "“new T[]”不能用于创建数组。请改用“new Array<T>()”。",
        "A parameter list must follow a generic type argument list. '(' expected.": "形参列表必须位于泛型类型实参列表之后。应为“(”。",
        "Multiple constructor implementations are not allowed.": "不允许存在多个构造函数实现。",
        "Unable to resolve external module '{0}'.": "无法解析外部模块“{0}”。",
        "Module cannot be aliased to a non-module type.": "模块的别名不能是非模块类型。",
        "A class may only extend another class.": "类只能扩展其他类。",
        "A class may only implement another class or interface.": "类只能实现其他类或接口。",
        "An interface may only extend another class or interface.": "接口只能扩展其他类或接口。",
        "Unable to resolve type.": "无法解析类型。",
        "Unable to resolve type of '{0}'.": "无法解析“{0}”的类型。",
        "Unable to resolve type parameter constraint.": "无法解析类型参数约束。",
        "Type parameter constraint cannot be a primitive type.": "类型参数约束不能是基元类型。",
        "Supplied parameters do not match any signature of call target.": "提供的参数与调用目标的任何签名都不匹配。",
        "Supplied parameters do not match any signature of call target:{NL}{0}": "提供的参数与调用目标的任何签名都不匹配: {NL}{0}",
        "Invalid 'new' expression.": "“new”表达式无效。",
        "Call signatures used in a 'new' expression must have a 'void' return type.": "“new”表达式中使用的调用签名必须具有“void”返回类型。",
        "Could not select overload for 'new' expression.": "无法对“new”表达式选择重载。",
        "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": "类型“{0}”不满足类型参数“{2}”的约束“{1}”。",
        "Could not select overload for 'call' expression.": "无法对“call”表达式选择重载。",
        "Cannot invoke an expression whose type lacks a call signature.": "无法调用其类型缺少调用签名的表达式。",
        "Calls to 'super' are only valid inside a class.": "对“super”的调用仅在类中有效。",
        "Generic type '{0}' requires {1} type argument(s).": "泛型类型“{0}”需要 {1} 类型参数。",
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": "无法确定数组文本类型。找不到数组元素的最佳通用类型。",
        "Could not find enclosing symbol for dotted name '{0}'.": "找不到点划线名称“{0}”的封闭符号。",
        "The property '{0}' does not exist on value of type '{1}'.": "类型为“{1}”的值中不存在属性“{0}”。",
        "Could not find symbol '{0}'.": "找不到符号“{0}”。",
        "'get' and 'set' accessor must have the same type.": "“get”和“set”访问器必须属于同一类型。",
        "'this' cannot be referenced in current location.": "“this”不能在当前位置引用。",
        "Static members cannot reference class type parameters.": "静态成员不能引用类类型参数。",
        "Class '{0}' is recursively referenced as a base type of itself.": "类“{0}”被作为其自身的基类型递归引用。",
        "Interface '{0}' is recursively referenced as a base type of itself.": "接口“{0}”被作为其自身的基类型递归引用。",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "只有构造函数、成员函数或派生类的成员访问器中才允许“super”属性访问。",
        "'super' cannot be referenced in non-derived classes.": "“super”不能在非派生类中引用。",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "当类包含初始化的属性或参数属性时，“super”调用必须是构造函数中的第一个语句。",
        "Constructors for derived classes must contain a 'super' call.": "派生类的构造函数必须包含“super”调用。",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "不允许在构造函数外部或构造函数内部的嵌套函数中调用 Super。",
        "'{0}.{1}' is inaccessible.": "无法访问“{0}.{1}”。",
        "'this' cannot be referenced within module bodies.": "“this”不能在模块体中引用。",
        "Invalid '+' expression - types not known to support the addition operator.": "“+”表达式无效 - 不知类型是否支持加法运算符。",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算术运算右侧必须是“any”、“number”或枚举类型。",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算术运算左侧必须是“any”、“number”或枚举类型。",
        "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": "一元算术运算的运算数类型必须是“any”、“number”或枚举类型。",
        "Variable declarations of a 'for' statement cannot use a type annotation.": "“for”语句的变量声明不能使用类型批注。",
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": "“for”语句的变量声明必须属于“string”或“any”类型。",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "“for...in”语句右侧必须是“any”类型、对象类型或类型参数。",
        "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": "“in”表达左侧部分必须是“any”、“string”或“number”类型。",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": "“in”表达式右侧必须是“any”类型、对象类型或类型参数。",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "“instanceof”表达式左侧必须是“any”类型、对象类型或类型参数。",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "“instanceof”表达式的右侧必须属于类型“any”或属于可分配给“Function”接口类型的类型。",
        "Setters cannot return a value.": "Setter 不能返回值。",
        "Tried to query type of uninitialized module '{0}'.": "已尝试查询未初始化的模块“{0}”的类型。",
        "Tried to set variable type to uninitialized module type '{0}'.": "已尝试将变量类型设置为未初始化的模块类型“{0}”。",
        "Type '{0}' does not have type parameters.": "类型“{0}”没有类型参数。",
        "Getters must return a value.": "Getter 必须返回一个值。",
        "Getter and setter accessors do not agree in visibility.": "Getter 和 setter 访问器在可见性上并不一致。",
        "Invalid left-hand side of assignment expression.": "赋值表达式左侧无效。",
        "Function declared a non-void return type, but has no return expression.": "函数声明了一个非 void 返回类型，但没有返回表达式。",
        "Cannot resolve return type reference.": "无法解析返回类型引用。",
        "Constructors cannot have a return type of 'void'.": "构造函数的返回类型不能为“void”",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "后续变量声明必须属于同一类型。 变量“{0}”必须属于类型“{1}”，但此处却为类型“{2}”。",
        "All symbols within a with block will be resolved to 'any'.": "with 块内的所有符号都将解析为“any”。",
        "Import declarations in an internal module cannot reference an external module.": "内部模块中的导入声明不能引用外部模块。",
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": "类 {0} 声明接口 {1}，但并没有实现它: {NL}{2}",
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": "类 {0} 将类 {1} 声明为接口，但并没有实现它: {NL}{2}",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "递增运算符或递减运算符的操作数必须是变量、属性或索引器。",
        "'this' cannot be referenced in static initializers in a class body.": "无法在类主体的静态初始值设定项中引用“this”。",
        "Class '{0}' cannot extend class '{1}':{NL}{2}": "类“{0}”不能扩展类“{1}”: {NL}{2}",
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": "接口“{0}”不能扩展类“{1}”: {NL}{2}",
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": "接口“{0}”不能扩展接口“{1}”: {NL}{2}",
        "Duplicate overload signature for '{0}'.": "“{0}”的重载签名重复。",
        "Duplicate constructor overload signature.": "构造函数重载签名重复。",
        "Duplicate overload call signature.": "重载调用签名重复。",
        "Duplicate overload construct signature.": "重载构造签名重复。",
        "Overload signature is not compatible with function definition.": "重载签名与函数定义不兼容。",
        "Overload signature is not compatible with function definition:{NL}{0}": "重载签名与函数定义不兼容: {NL}{0}",
        "Overload signatures must all be public or private.": "重载签名必须全部为公共签名或私有签名。",
        "Overload signatures must all be exported or not exported.": "重载签名必须全部导出或全部不导出。",
        "Overload signatures must all be ambient or non-ambient.": "重载签名必须全部为环境签名或非环境签名。",
        "Overload signatures must all be optional or required.": "重载签名必须全部为可选签名或必需签名。",
        "Specialized overload signature is not assignable to any non-specialized signature.": "指定的重载签名不可分配给任何非专用化签名。",
        "'this' cannot be referenced in constructor arguments.": "“this”不能在构造函数参数中引用。",
        "Instance member cannot be accessed off a class.": "实例成员不能在类外部进行访问。",
        "Untyped function calls may not accept type arguments.": "非类型化函数调用不能接受类型参数。",
        "Non-generic functions may not accept type arguments.": "非泛型函数不能接受类型参数。",
        "A generic type may not reference itself with a wrapped form of its own type parameters.": "泛型类型不能使用其自己的类型参数的包装形式引用自身。",
        "Rest parameters must be array types.": "Rest 参数必须是数组类型。",
        "Overload signature implementation cannot use specialized type.": "重载签名实现不能使用专用化类型。",
        "Export assignments may only be used at the top-level of external modules.": "导出分配只能在顶级外部模块中使用。",
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": "只能使用变量、函数、类、接口、枚举和内部模块来导出分配。",
        "Only public methods of the base class are accessible via the 'super' keyword.": "只有基类的公共方法可通过“super”关键字访问。",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.": "数值索引器类型“{0}”必须可分配给字符串索引器类型“{1}”。",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}": "数值索引器类型“{0}”必须可分配给字符串索引器类型“{1}”:{NL}{2}",
        "All numerically named properties must be assignable to numeric indexer type '{0}'.": "所有以数值命名的属性都必须可分配给数值索引器类型“{0}”。",
        "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}": "所有以数值命名的属性都必须可分配给数值索引器类型“{0}”:{NL}{1}",
        "All named properties must be assignable to string indexer type '{0}'.": "所有命名属性都必须可分配给字符串索引器类型“{0}”。",
        "All named properties must be assignable to string indexer type '{0}':{NL}{1}": "所有命名属性都必须可分配给字符串索引器类型“{0}”:{NL}{1}",
        "Generic type references must include all type arguments.": "泛型类型引用必须包括所有类型参数。",
        "Default arguments are only allowed in implementation.": "实现中只允许使用默认参数。",
        "Overloads cannot differ only by return type.": "仅通过返回类型不能区分重载。",
        "Function expression declared a non-void return type, but has no return expression.": "函数表达式声明了一个非 void 返回类型，但没有返回表达式。",
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": "只能使用变量、函数、类、接口、枚举和内部模块来构建引用内部模块中的标识符的导入声明。",
        "Could not find symbol '{0}' in module '{1}'.": "未能找到模块“{1}”中的符号“{0}”。",
        "Unable to resolve module reference '{0}'.": "无法解析模块引用“{0}”。",
        "Could not find module '{0}' in module '{1}'.": "未能找到模块“{1}”中的模块“{0}”。",
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": "为已导出的导入声明“{0}”分配带具有私有类型“{1}”或正在使用该类型的类型的值。",
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": "为已导出的导入声明“{0}”分配带有正在使用无法访问的模块“{1}”的类型的值。",
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": "为已导出的导入声明“{0}”分配具有私有类型“{1}”或正在使用该类型的类型。",
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": "为已导出的导入声明“{0}”分配正在使用无法访问的模块“{1}”的类型。",
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": "为已导出的导入声明“{0}”分配具有无法访问的模块“{1}”或正在使用该模块的容器。",
        "Type name '{0}' in extends clause does not reference constructor function for '{1}'.": "扩展子句中的类型名称“{0}”不能引用“{1}”的构造函数。",
        "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": "导入声明中的内部模块引用“{0}”不引用“{1}”的模块实例。",
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": "模块“{0}”不能与另一个文件“{2}”中之前的“{1}”声明合并。",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": "接口“{0}”不能同时扩展类型“{1}”和“{2}”:{NL}{3}",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "参数“{0}”的初始值设定项不能引用在它之后声明的标识符“{1}”。",
        "Ambient external module declaration cannot be reopened.": "无法重新打开环境外部模块声明。",
        "All declarations of merged declaration '{0}' must be exported or not exported.": "合并声明“{0}”的所有声明必须全部导出或全部不导出。",
        "'super' cannot be referenced in constructor arguments.": "不能在构造函数参数中引用“super”。",
        "Return type of constructor signature must be assignable to the instance type of the class.": "构造函数签名的返回类型必须可分配给类的实例类型。",
        "Ambient external module declaration must be defined in global context.": "环境外部模块声明必须在全局上下文中定义。",
        "Ambient external module declaration cannot specify relative module name.": "环境外部模块声明无法指定相对模块名称。",
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": "环境外部模块声明中的导入声明不能通过相对外部模块名称引用外部模块。",
        "Could not find the best common type of types of all return statement expressions.": "找不到所有返回语句表达式的类型的最佳通用类型。",
        "Import declaration cannot refer to external module reference when --noResolve option is set.": "当设置 --noResolve 选项时，导入声明无法引用外部模块引用。",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "标识符“_this”重复。编译器使用变量声明“_this“来捕获“this”引用。",
        "'continue' statement can only be used within an enclosing iteration statement.": "“continue”语句只能在封闭迭代语句内使用。",
        "'break' statement can only be used within an enclosing iteration or switch statement.": "“break”语句只能在封闭迭代或 switch 语句内使用。",
        "Jump target not found.": "找不到跳转目标。",
        "Jump target cannot cross function boundary.": "跳转目标不能跨越函数边界。",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "标识符“_super”重复。编译器使用“_super”捕获基类引用。",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "表达式解析为变量声明“_this”，编译器使用“_this”来捕获“this”引用。",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "表达式解析为“_super”，编译器使用“_super”来捕获基类引用。",
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "导出接口中的构造函数签名的 TypeParameter“{0}”当前具有或使用私有类型“{1}”。",
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "导出接口中的调用签名的 TypeParameter“{0}”当前具有或使用私有类型“{1}”。",
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": "导出类中的公共静态方法的 TypeParameter“{0}”当前具有或使用私有类型“{1}”。",
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": "导出类中的公共方法的 TypeParameter“{0}”当前具有或使用私有类型“{1}”。",
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": "导出接口中的方法的 TypeParameter“{0}”当前具有或使用私有类型“{1}”。",
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": "导出函数的 TypeParameter“{0}”当前具有或使用私有类型“{1}”。",
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "导出接口中的构造函数签名的 TypeParameter“{0}”当前使用无法访问的模块 {1}。",
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": "导出接口中的调用签名的 TypeParameter“{0}”当前使用无法访问的模块 {1}",
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": "导出类中的公共静态方法的 TypeParameter“{0}”当前使用无法访问的模块 {1}。",
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": "导出类中的公共方法的 TypeParameter“{0}”当前使用无法访问的模块 {1}。",
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": "导出接口中的方法的 TypeParameter“{0}”当前使用无法访问的模块 {1}。",
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": "导出函数的 TypeParameter“{0}”当前使用无法访问的模块 {1}。",
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": "导出类的 TypeParameter“{0}”当前具有或使用私有类型“{1}”。",
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": "导出接口的 TypeParameter“{0}”当前具有或使用私有类型“{1}”。",
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": "导出类的 TypeParameter“{0}”当前使用无法访问的模块 {1}。",
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": "导出接口的 TypeParameter“{0}”当前使用无法访问的模块 {1}。",
        "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": "标识符“_i”重复。编译器使用“_i”初始化 rest 参数。",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "标识符“arguments”重复。编译器使用“arguments”初始化 rest 参数。",
        "Type of conditional '{0}' must be identical to '{1}' or '{2}'.": "条件“{0}”的类型必须与“{1}”或“{2}”相同。",
        "Type of conditional '{0}' must be identical to '{1}', '{2}' or '{3}'.": "条件“{0}”的类型必须与“{1}”、“{2}”或“{3}”相同。",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": "标识符“{0}”重复。编译器在外部模块的顶层范围中保留名称“{1}”。",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "类型参数约束不能引用同一类型参数列表中的任何类型参数。",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "实例成员变量“{0}”的初始值设定项不能引用在构造函数中声明的标识符“{1}”。",
        "Parameter '{0}' cannot be referenced in its initializer.": "参数“{0}”初始值设定项中不能引用它自身。",
        "Duplicate string index signature.": "字符串索引签名重复。",
        "Duplicate number index signature.": "数字索引签名重复。",
        "All declarations of an interface must have identical type parameters.": "接口的所有声明必须具有相同的类型参数。",
        "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.": "表达式解析为编译器用于初始化 rest 参数的变量声明“_i”。",
        "Type '{0}' is missing property '{1}' from type '{2}'.": "类型“{0}”缺少类型“{2}”中的属性“{1}”。",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": "类型“{1}”和“{2}”的属性“{0}”的类型不兼容。",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": "类型“{1}”和“{2}”的属性“{0}”的类型不兼容: {NL}{3}",
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "类型“{1}”中定义为私有的属性“{0}”在类型“{2}”中定义为公共。",
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "类型“{1}”中定义为公共的属性“{0}”在类型“{2}”中定义为私有。",
        "Types '{0}' and '{1}' define property '{2}' as private.": "类型“{0}”和“{1}”将属性“{2}”定义为私有。",
        "Call signatures of types '{0}' and '{1}' are incompatible.": "类型“{0}”和“{1}”的调用签名不兼容。",
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "类型“{0}”和“{1}”的调用签名不兼容: {NL}{2}",
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": "类型“{0}”需要调用签名，但类型“{1}”没有调用签名。",
        "Construct signatures of types '{0}' and '{1}' are incompatible.": "类型“{0}”和“{1}”的构造签名不兼容。",
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "类型“{0}”和“{1}”的构造签名不兼容: {NL}{2}。",
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": "类型“{0}”需要构造签名，但类型“{1}”没有构造签名。",
        "Index signatures of types '{0}' and '{1}' are incompatible.": "类型“{0}”和“{1}”的索引签名不兼容。",
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "类型“{0}”和“{1}”的索引签名不兼容: {NL}{2}",
        "Call signature expects {0} or fewer parameters.": "调用签名的参数应为 {0} 个或更少。",
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": "无法对类型为“{2}”的参数 {1} 应用类型“{0}”。",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "类“{0}”将“{1}”定义为实例成员访问器，但扩展类“{2}”将其定义为实例成员函数。",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "类“{0}”将“{1}”定义为实例成员属性，但扩展类“{2}”将其定义为实例成员函数。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员访问器。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员属性。",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": "类“{1}”和类“{2}”的静态属性“{0}”的类型不兼容。",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": "类“{1}”和类“{2}”的静态属性“{0}”的类型不兼容: {NL}{3}",
        "Type reference cannot refer to container '{0}'.": "类型引用不能引用容器“{0}”。",
        "Type reference must refer to type.": "类型引用必须引用类型。",
        "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.": "在具有多个声明的枚举中，只有一个声明可以针对第一个枚举元素发出初始值设定项。",
        " (+ {0} overload(s))": " (+ {0} 重载)",
        "Variable declaration cannot have the same name as an import declaration.": "变量声明不能与导入声明具有相同名称。",
        "Signature expected {0} type arguments, got {1} instead.": "签名需要 {0} 个类型参数，但获得 {1} 个。",
        "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": "属性“{0}”在类型“{1}”中被定义为可选，但在类型“{2}”中为必需。",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.": "源自无限扩展的类型引用的类型“{0}”和“{1}”不引用同名类型。",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.": "源自无限扩展的类型引用的类型“{0}”和“{1}”具有不兼容的类型参数。",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}": "源自无限扩展的类型引用的类型“{0}”和“{1}”具有不兼容的类型参数:{NL}{2}",
        "Named properties '{0}' of types '{1}' and '{2}' are not identical.": "类型“{1}”和“{2}”的命名属性“{0}”不相同。",
        "Types of string indexer of types '{0}' and '{1}' are not identical.": "类型“{0}”和“{1}”的字符串索引器的类型不相同。",
        "Types of number indexer of types '{0}' and '{1}' are not identical.": "类型“{0}”和“{1}”的数字索引器的类型不相同。",
        "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}": "类型“{0}”中的数值索引器的类型不可分配给类型“{1}”中的字符串索引器类型。{NL}{2}",
        "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}": "类型“{1}”中属性“{0}”的类型不可分配给类型“{2}”中的字符串索引器类型。{NL}{3}",
        "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}": "类型“{1}”中属性“{0}”的类型不可分配给类型“{2}”中的数值索引器类型。{NL}{3}",
        "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "静态属性“{0}”在类型“{1}”中被定义为私有，在类型“{2}”中被定义为公共。",
        "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "静态属性“{0}”在类型“{1}”中被定义为公共，在类型“{2}”中被定义为私有。",
        "Types '{0}' and '{1}' define static property '{2}' as private.": "类型“{0}”和“{1}”将静态属性“{2}”定义为私有。",
        "Current host does not support '{0}' option.": "当前主机不支持“{0}”选项。",
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": "不支持 ECMAScript 目标版本“{0}”。请指定有效的目标版本:“{1}”(默认)或“{2}”",
        "Module code generation '{0}' not supported.": "不支持模块代码生成“{0}”。",
        "Could not find file: '{0}'.": "找不到文件:“{0}”。",
        "A file cannot have a reference to itself.": "文件不能引用自身。",
        "Cannot resolve referenced file: '{0}'.": "无法解析引用的文件:“{0}”。",
        "Cannot find the common subdirectory path for the input files.": "找不到输入文件的公共子目录路径。",
        "Emit Error: {0}.": "发出错误: {0}.",
        "Cannot read file '{0}': {1}": "无法读取文件“{0}”: {1}",
        "Unsupported file encoding.": "文件编码不受支持。",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "区域设置必须采用 <语言> 或 <语言>-<区域> 形式。例如“{0}”或“{1}”。",
        "Unsupported locale: '{0}'.": "区域设置不受支持:“{0}”。",
        "Execution Failed.{NL}": "执行失败。{NL}",
        "Invalid call to 'up'": "对“up”的调用无效",
        "Invalid call to 'down'": "对“down”的调用无效",
        "Base64 value '{0}' finished with a continuation bit.": "Base64 值“{0}”以继续位结束。",
        "Unknown option '{0}'": "未知的选项“{0}”。",
        "Expected {0} arguments to message, got {1} instead.": "需要 {0} 消息参数，但获得 {1}。",
        "Expected the message '{0}' to have {1} arguments, but it had {2}": "消息“{0}”本应有 {1} 个参数，但实际有 {2} 个参数",
        "Could not delete file '{0}'": "无法删除文件“{0}”",
        "Could not create directory '{0}'": "无法创建目录“{0}”",
        "Error while executing file '{0}': ": "执行文件“{0}”时出错: ",
        "Cannot compile external modules unless the '--module' flag is provided.": "无法编译外部模块，除非提供“--module”标志。",
        "Option mapRoot cannot be specified without specifying sourcemap option.": "在未指定 sourcemap 选项的情况下，无法指定选项 mapRoot。",
        "Option sourceRoot cannot be specified without specifying sourcemap option.": "在未指定 sourcemap 选项的情况下，无法指定选项 sourceRoot。",
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": "在未指定 sourcemap 选项的情况下，无法指定选项 mapRoot 和 sourceRoot。",
        "Option '{0}' specified without '{1}'": "指定的选项“{0}”没有“{1}”",
        "'codepage' option not supported on current platform.": "当前平台上不支持“代码页”选项。",
        "Concatenate and emit output to single file.": "连接输出并将其发出到单个文件。",
        "Generates corresponding {0} file.": "生成相应的 {0} 文件。",
        "Specifies the location where debugger should locate map files instead of generated locations.": "指定调试器应将映射文件放置到的位置而不是生成的位置。",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "指定调试器应将 TypeScript 文件放置到的位置而不是源位置。",
        "Watch input files.": "监视输入文件。",
        "Redirect output structure to the directory.": "将输出结构重定向到目录。",
        "Do not emit comments to output.": "不要将注释发出到输出中。",
        "Skip resolution and preprocessing.": "跳过解析并重新处理。",
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": "指定 ECMAScript 目标版本:“{0}”(默认)或“{1}”",
        "Specify module code generation: '{0}' or '{1}'": "指定模块代码生成:“{0}”或“{1}”",
        "Print this message.": "打印此消息。",
        "Print the compiler's version: {0}": "打印编译器版本: {0}",
        "Allow use of deprecated '{0}' keyword when referencing an external module.": "允许在引用外部模块时使用已弃用的“{0}”关键字。",
        "Specify locale for errors and messages. For example '{0}' or '{1}'": "为错误和消息指定区域设置。例如“{0}”或“{1}”",
        "Syntax:   {0}": "语法:   {0}",
        "options": "选项",
        "file1": "文件",
        "Examples:": "示例:",
        "Options:": "选项:",
        "Insert command line options and files from a file.": "从文件插入命令行选项和文件。",
        "Version {0}": "版本 {0}",
        "Use the '{0}' flag to see options.": "使用“{0}”标记可查看选项。",
        "{NL}Recompiling ({0}):": "{NL}正在编译({0}):",
        "STRING": "字符串",
        "KIND": "种类",
        "file2": "文件",
        "VERSION": "版本",
        "LOCATION": "位置",
        "DIRECTORY": "目录",
        "NUMBER": "数值",
        "Specify the codepage to use when opening source files.": "指定打开源文件时要使用的代码页。",
        "Additional locations:": "其他位置:",
        "This version of the Javascript runtime does not support the '{0}' function.": "此版本的 JavaScript 运行时不支持“{0}”函数。",
        "Unknown rule.": "未知规则。",
        "Invalid line number ({0})": "行号无效({0})",
        "Warn on expressions and declarations with an implied 'any' type.": "有关带隐式“any”类型的表达式和声明的警告。",
        "Variable '{0}' implicitly has an 'any' type.": "变量“{0}”隐式具有“any”类型。",
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": "“{1}”的参数“{0}”隐式具有“any”类型。",
        "Parameter '{0}' of function type implicitly has an 'any' type.": "函数类型的参数“{0}”隐式具有“any”类型。",
        "Member '{0}' of object type implicitly has an 'any' type.": "对象类型的成员“{0}”隐式具有“any”类型。",
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": "缺少构造函数签名的“new”表达式隐式具有“any”类型。",
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": "缺少返回类型批注的“{0}”隐式具有“any”返回类型。",
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少返回类型批注的函数表达式隐式具有“any”返回类型。",
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": "Lambda 函数的参数“{0}”隐式具有“any”类型。",
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少返回类型批注的构造函数签名隐式具有“any”返回类型。",
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少返回类型批注的 lambda 函数隐式具有“any”返回类型。",
        "Array Literal implicitly has an 'any' type from widening.": "数组文本隐式具有来自 Widening 的“any”类型。",
        "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": "缺少“get”访问器以及“set”访问器上的参数类型注释的“{0}”隐式具有“any”类型。",
        "Index signature of object type implicitly has an 'any' type.": "对象类型的索引签名隐式具有“any”类型。",
        "Object literal's property '{0}' implicitly has an 'any' type from widening.": "对象文本的属性“{0}”隐式具有来自 Widening 的“any”类型。"
}