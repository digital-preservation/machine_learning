{
        "error TS{0}: {1}": "錯誤 TS{0}: {1}",
        "warning TS{0}: {1}": "警告 TS{0}: {1}",
        "Unrecognized escape sequence.": "無法辨認的逸出序列。",
        "Unexpected character {0}.": "未預期的字元 {0}。",
        "Missing close quote character.": "缺少右引號字元。",
        "Identifier expected.": "必須有識別項。",
        "'{0}' keyword expected.": "必須是 '{0}' 關鍵字。",
        "'{0}' expected.": "必須是 '{0}'。",
        "Identifier expected; '{0}' is a keyword.": "必須有識別項; '{0}' 為關鍵字。",
        "Automatic semicolon insertion not allowed.": "不允許自動插入分號。",
        "Unexpected token; '{0}' expected.": "未預期的語彙基元; 必須是 '{0}'。",
        "Trailing separator not allowed.": "不允許尾端分隔符號。",
        "'*/' expected.": "必須是 '*/'。",
        "'public' or 'private' modifier must precede 'static'.": "'public' 或 'private' 修飾詞必須在 'static' 之前。",
        "Unexpected token.": "未預期的語彙基元。",
        "Catch clause parameter cannot have a type annotation.": "Catch 子句參數不能有類型註釋。",
        "Rest parameter must be last in list.": "剩餘參數必須是清單中的最後一項。",
        "Parameter cannot have question mark and initializer.": "參數不能有問號和初始設定式。",
        "Required parameter cannot follow optional parameter.": "必要參數必須在選擇性參數之前。",
        "Index signatures cannot have rest parameters.": "索引簽章不能有剩餘參數。",
        "Index signature parameter cannot have accessibility modifiers.": "索引簽章參數不能有存取範圍修飾詞。",
        "Index signature parameter cannot have a question mark.": "索引簽章參數不能有問號。",
        "Index signature parameter cannot have an initializer.": "索引簽章參數不能有初始設定式。",
        "Index signature must have a type annotation.": "索引簽章必須有類型註釋。",
        "Index signature parameter must have a type annotation.": "索引簽章參數必須有類型註釋。",
        "Index signature parameter type must be 'string' or 'number'.": "索引簽章參數的類型必須是 'string' 或 'number'。",
        "'extends' clause already seen.": "已經有 'extends' 子句。",
        "'extends' clause must precede 'implements' clause.": "'extends' 子句必須在 'implements' 子句之前。",
        "Classes can only extend a single class.": "類別只能擴充一個類別。",
        "'implements' clause already seen.": "已經看到 'implements' 子句。",
        "Accessibility modifier already seen.": "已經有存取範圍修飾詞。",
        "'{0}' modifier must precede '{1}' modifier.": "'{0}' 修飾詞必須在 '{1}' 修飾詞之前。",
        "'{0}' modifier already seen.": "已經有 '{0}' 修飾詞。",
        "'{0}' modifier cannot appear on a class element.": "類別項目不能有 '{0}' 修飾詞。",
        "Interface declaration cannot have 'implements' clause.": "介面宣告不能有'implements' 子句。",
        "'super' invocation cannot have type arguments.": "'super' 引動不能有類型引數。",
        "Only ambient modules can use quoted names.": "只有環境模組可以使用以引號括住的名稱。",
        "Statements are not allowed in ambient contexts.": "環境內容中不能有陳述式。",
        "Implementations are not allowed in ambient contexts.": "環境內容中不允許實作。",
        "'declare' modifier not allowed for code already in an ambient context.": "已經位於環境內容中的程式碼不能使用 'declare' 修飾詞。",
        "Initializers are not allowed in ambient contexts.": "環境內容中不能有初始設定式。",
        "Parameter property declarations can only be used in a non-ambient constructor declaration.": "參數屬性宣告只能在非環境建構函式宣告中使用。",
        "Function implementation expected.": "必須實作函式。",
        "Constructor implementation expected.": "必須實作建構函式。",
        "Function overload name must be '{0}'.": "函式多載名稱必須是 '{0}'。",
        "'{0}' modifier cannot appear on a module element.": "模組項目不能有 '{0}' 修飾詞。",
        "'declare' modifier cannot appear on an interface declaration.": "介面宣告不能有 'declare' 修飾詞。",
        "'declare' modifier required for top level element.": "最上層項目需要 'declare' 修飾詞。",
        "Rest parameter cannot be optional.": "剩餘參數不能是選擇性參數。",
        "Rest parameter cannot have an initializer.": "剩餘參數不能有初始設定式。",
        "'set' accessor must have one and only one parameter.": "'set' 存取子只能有一個參數。",
        "'set' accessor parameter cannot be optional.": "'set' 存取子參數是必要參數。",
        "'set' accessor parameter cannot have an initializer.": "'set' 存取子參數不能有初始設定式。",
        "'set' accessor cannot have rest parameter.": "'set' 存取子不能有剩餘參數。",
        "'get' accessor cannot have parameters.": "'get' 存取子不能有參數。",
        "Modifiers cannot appear here.": "這裡不能有修飾詞。",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "只有在以 ECMAScript 5 (含) 以上版本為目標時才能使用存取子。",
        "Class name cannot be '{0}'.": "類別名稱不能是 '{0}'。",
        "Interface name cannot be '{0}'.": "介面名稱不能是 '{0}'。",
        "Enum name cannot be '{0}'.": "列舉名稱不能是 '{0}'。",
        "Module name cannot be '{0}'.": "模組名稱不能是 '{0}'。",
        "Enum member must have initializer.": "列舉成員必須有初始設定式。",
        "Export assignment cannot be used in internal modules.": "匯出指派無法在內部模組中使用。",
        "Export assignment not allowed in module with exported element.": "如果模組中有已匯出的項目，您就無法使用匯出指派。",
        "Module cannot have multiple export assignments.": "模組不能有多個匯出指派。",
        "Ambient enum elements can only have integer literal initializers.": "環境列舉元素只能有整數常值初始設定式。",
        "module, class, interface, enum, import or statement": "模組、類別、介面、列舉、匯入或陳述式",
        "constructor, function, accessor or variable": "建構函式、函式、存取子或變數",
        "statement": "陳述式",
        "case or default clause": "case 或預設子句",
        "identifier": "識別項",
        "call, construct, index, property or function signature": "呼叫、建構、索引、屬性或函式簽章",
        "expression": "運算式",
        "type name": "類型名稱",
        "property or accessor": "屬性或存取子",
        "parameter": "參數",
        "type": "類型",
        "type parameter": "類型參數",
        "'declare' modifier not allowed on import declaration.": "匯入宣告不能有 'declare' 修飾詞。",
        "Function overload must be static.": "函式多載必須是靜態的。",
        "Function overload must not be static.": "函式多載不可以是靜態的。",
        "Parameter property declarations cannot be used in a constructor overload.": "參數屬性宣告不可以用在建構函式多載中。",
        "Invalid 'reference' directive syntax.": "無效的 'reference' 指示詞語法。",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "以 ECMAScript 5 (含) 以上版本為目標時，無法使用八進位常值。",
        "Accessors are not allowed in ambient contexts.": "環境內容中不能有存取子。",
        "'{0}' modifier cannot appear on a constructor declaration.": "建構函式宣告不能有 '{0}' 修飾詞。",
        "'{0}' modifier cannot appear on a parameter.": "參數不能有 '{0}' 修飾詞。",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "只有 'for...in' 陳述式中才可以使用單一變數宣告。",
        "Type parameters cannot appear on a constructor declaration.": "建構函式宣告不能有類型參數。",
        "Type annotation cannot appear on a constructor declaration.": "建構函式宣告不能有類型註釋。",
        "Duplicate identifier '{0}'.": "識別項 '{0}' 重複。",
        "The name '{0}' does not exist in the current scope.": "名稱 '{0}' 不存在於目前的範圍中。",
        "The name '{0}' does not refer to a value.": "名稱 '{0}' 並未參考值。",
        "'super' can only be used inside a class instance method.": "'super' 只能在類別執行個體方法內使用。",
        "The left-hand side of an assignment expression must be a variable, property or indexer.": "指派運算式的左邊必須為變數、屬性或索引子。",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "無法呼叫類型為 '{0}' 的值。您是不是要包含 'new'?",
        "Value of type '{0}' is not callable.": "無法呼叫類型為 '{0}' 的值。",
        "Value of type '{0}' is not newable.": "無法為類型為 '{0}' 的值建立執行個體。",
        "Value of type '{0}' is not indexable by type '{1}'.": "無法依類型 '{1}' 對類型為 '{0}' 的值進行索引。",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "運算子 '{0}' 無法套用至類型 '{1}' 和 '{2}'。",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": "運算子 '{0}' 無法套用至類型 '{1}' 和 '{2}': {3}",
        "Cannot convert '{0}' to '{1}'.": "無法將 '{0}' 轉換成 '{1}'。",
        "Cannot convert '{0}' to '{1}':{NL}{2}": "無法將 '{0}' 轉換成 '{1}':{NL}{2}",
        "Expected var, class, interface, or module.": "必須是 var、class、interface 或 module。",
        "Operator '{0}' cannot be applied to type '{1}'.": "運算子 '{0}' 無法套用至類型 '{1}'。",
        "Getter '{0}' already declared.": "已宣告 getter '{0}'。",
        "Setter '{0}' already declared.": "已宣告 setter '{0}'。",
        "Exported class '{0}' extends private class '{1}'.": "匯出類別 '{0}' 擴充私用類別 '{1}'。",
        "Exported class '{0}' implements private interface '{1}'.": "匯出類別 '{0}' 實作私用介面 '{1}'。",
        "Exported interface '{0}' extends private interface '{1}'.": "匯出介面 '{0}' 擴充私用介面 '{1}'。",
        "Exported class '{0}' extends class from inaccessible module {1}.": "匯出類別 '{0}' 從無法存取的模組 {1} 擴充類別。",
        "Exported class '{0}' implements interface from inaccessible module {1}.": "匯出類別 '{0}' 從無法存取的模組 {1} 實作介面。",
        "Exported interface '{0}' extends interface from inaccessible module {1}.": "匯出介面 '{0}' 從無法存取的模組 {1} 擴充介面。",
        "Public static property '{0}' of exported class has or is using private type '{1}'.": "匯出類別的公用靜態屬性 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Public property '{0}' of exported class has or is using private type '{1}'.": "匯出類別的公用屬性 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Property '{0}' of exported interface has or is using private type '{1}'.": "匯出介面的屬性 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Exported variable '{0}' has or is using private type '{1}'.": "匯出變數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Public static property '{0}' of exported class is using inaccessible module {1}.": "匯出類別的公用靜態屬性 '{0}' 正在使用無法存取的模組 {1}。",
        "Public property '{0}' of exported class is using inaccessible module {1}.": "匯出類別的公用屬性 '{0}' 正在使用無法存取的模組 {1}。",
        "Property '{0}' of exported interface is using inaccessible module {1}.": "匯出介面的屬性 '{0}' 正在使用無法存取的模組 {1}。",
        "Exported variable '{0}' is using inaccessible module {1}.": "匯出變數 '{0}' 正在使用無法存取的模組 {1}。",
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": "匯出類別之建構函式的參數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": "匯出類別之公用靜態屬性 setter 的參數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": "匯出類別之公用屬性 setter 的參數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "匯出介面之建構函式的參數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "匯出介面之呼叫簽章的參數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": "匯出類別之公用靜態方法的參數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": "匯出類別之公用方法的參數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": "匯出介面之方法的參數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Parameter '{0}' of exported function has or is using private type '{1}'.": "匯出函式的參數 '{0}' 已經或正在使用私用類型 '{1}'。",
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": "匯出類別之建構函式的參數 '{0}' 正在使用無法存取的模組 {1}。",
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": "匯出類別之公用靜態屬性 setter 的參數 '{0}' 正在使用無法存取的模組 {1}。",
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": "匯出類別之公用屬性 setter 的參數 '{0}' 正在使用無法存取的模組 {1}。",
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "匯出介面之建構函式簽章的參數 '{0}' 正在使用無法存取的模組 {1}。",
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": "匯出介面之呼叫簽章的參數 '{0}' 正在使用無法存取的模組 {1}",
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": "匯出類別之公用靜態方法的參數 '{0}' 正在使用無法存取的模組 {1}。",
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": "匯出類別之公用方法的參數 '{0}' 正在使用無法存取的模組 {1}。",
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": "匯出介面之方法的參數 '{0}' 正在使用無法存取的模組 {1}。",
        "Parameter '{0}' of exported function is using inaccessible module {1}.": "匯出函式的參數 '{0}' 正在使用無法存取的模組 {1}。",
        "Return type of public static property getter from exported class has or is using private type '{0}'.": "匯出類別之公用靜態屬性 getter 的傳回類型已經或正在使用私用類型 '{0}'。",
        "Return type of public property getter from exported class has or is using private type '{0}'.": "匯出類別之公用屬性 getter 的傳回類型已經或正在使用私用類型 '{0}'。",
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": "匯出介面之建構函式簽章的傳回類型已經或正在使用私用類型 '{0}'。",
        "Return type of call signature from exported interface has or is using private type '{0}'.": "匯出介面之呼叫簽章的傳回類型已經或正在使用私用類型 '{0}'。",
        "Return type of index signature from exported interface has or is using private type '{0}'.": "匯出介面之索引簽章的傳回類型已經或正在使用私用類型 '{0}'。",
        "Return type of public static method from exported class has or is using private type '{0}'.": "匯出類別之公用靜態方法的傳回類型已經或正在使用私用類型 '{0}'。",
        "Return type of public method from exported class has or is using private type '{0}'.": "匯出類別之公用方法的傳回類型已經或正在使用私用類型 '{0}'。",
        "Return type of method from exported interface has or is using private type '{0}'.": "匯出介面之方法的傳回類型已經或正在使用私用類型 '{0}'。",
        "Return type of exported function has or is using private type '{0}'.": "匯出函式的傳回類型已經或正在使用私用類型 '{0}'。",
        "Return type of public static property getter from exported class is using inaccessible module {0}.": "匯出類別之公用靜態屬性 getter 的傳回類型正在使用無法存取的模組 {0}。",
        "Return type of public property getter from exported class is using inaccessible module {0}.": "匯出類別之公用屬性 getter 的傳回類型正在使用無法存取的模組 {0}。",
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": "匯出介面之建構函式簽章的傳回類型正在使用無法存取的模組 {0}。",
        "Return type of call signature from exported interface is using inaccessible module {0}.": "匯出介面之呼叫簽章的傳回類型正在使用無法存取的模組 {0}。",
        "Return type of index signature from exported interface is using inaccessible module {0}.": "匯出介面之索引簽章的傳回類型正在使用無法存取的模組 {0}。",
        "Return type of public static method from exported class is using inaccessible module {0}.": "匯出類別之公用靜態方法的傳回類型正在使用無法存取的模組 {0}。",
        "Return type of public method from exported class is using inaccessible module {0}.": "匯出類別之公用方法的傳回類型正在使用無法存取的模組 {0}。",
        "Return type of method from exported interface is using inaccessible module {0}.": "匯出介面之方法的傳回類型正在使用無法存取的模組 {0}。",
        "Return type of exported function is using inaccessible module {0}.": "匯出函式的傳回類型正在使用無法存取的模組 {0}。",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "'new T[]' 不能用來建立陣列。請改用 'new Array<T>()'。",
        "A parameter list must follow a generic type argument list. '(' expected.": "參數清單必須接在泛型類型引數清單之後。必須有 '('。",
        "Multiple constructor implementations are not allowed.": "不允許多個建構函式實作。",
        "Unable to resolve external module '{0}'.": "無法解析外部模組 '{0}'。",
        "Module cannot be aliased to a non-module type.": "無法將模組的別名設定為非模組類型。",
        "A class may only extend another class.": "類別只能擴充其他類別。",
        "A class may only implement another class or interface.": "類別只能實作其他類別或介面。",
        "An interface may only extend another class or interface.": "介面只能擴充其他類別或介面。",
        "Unable to resolve type.": "無法解析類型。",
        "Unable to resolve type of '{0}'.": "無法解析 '{0}' 的類型。",
        "Unable to resolve type parameter constraint.": "無法解析類型參數條件約束。",
        "Type parameter constraint cannot be a primitive type.": "類型參數條件約束不能是基本類型。",
        "Supplied parameters do not match any signature of call target.": "提供的參數與任何呼叫目標簽章都不符。",
        "Supplied parameters do not match any signature of call target:{NL}{0}": "提供的參數與任何呼叫目標簽章都不符:{NL}{0}",
        "Invalid 'new' expression.": "無效的 'new' 運算式。",
        "Call signatures used in a 'new' expression must have a 'void' return type.": "在 'new' 運算式中使用之呼叫簽章的傳回類型必須是 'void'。",
        "Could not select overload for 'new' expression.": "無法選取 'new' 運算式的多載。",
        "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": "類型 '{0}' 無法滿足類型參數 '{2}' 的條件約束 '{1}'。",
        "Could not select overload for 'call' expression.": "無法選取 'call' 運算式的多載。",
        "Cannot invoke an expression whose type lacks a call signature.": "無法叫用缺少呼叫簽章之類型的運算式。",
        "Calls to 'super' are only valid inside a class.": "只有在類別中才能有效呼叫 'super'。",
        "Generic type '{0}' requires {1} type argument(s).": "泛型類型 '{0}' 需要 {1} 個類型引數。",
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": "無法判斷陣列常值的類型。找不到陣列元素的最佳一般類型。",
        "Could not find enclosing symbol for dotted name '{0}'.": "找不到含點號名稱 '{0}' 的封入符號。",
        "The property '{0}' does not exist on value of type '{1}'.": "類型為 '{1}' 的值並沒有屬性 '{0}'。",
        "Could not find symbol '{0}'.": "找不到符號 '{0}'。",
        "'get' and 'set' accessor must have the same type.": "'get' 和 'set' 存取子的類型必須相同。",
        "'this' cannot be referenced in current location.": "您無法在目前的位置中參考 'this'。",
        "Static members cannot reference class type parameters.": "靜態成員不能參考類別類型參數。",
        "Class '{0}' is recursively referenced as a base type of itself.": "類別 '{0}' 被當做自己的基底類型遞迴參考。",
        "Interface '{0}' is recursively referenced as a base type of itself.": "介面 '{0}' 被當做自己的基底類型遞迴參考。",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "您只能在建構函式、成員函式，或衍生類別的成員存取子中存取 'super' 屬性。",
        "'super' cannot be referenced in non-derived classes.": "您無法在非衍生的類別中參考 'super'。",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "如果類別包含已初始化的屬性或參數屬性，'super' 呼叫就必須是建構函式中的第一個陳述式。",
        "Constructors for derived classes must contain a 'super' call.": "衍生類別的建構函式必須包含 'super' 呼叫。",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "不能在建構函式外部或建構函式內的巢狀函式中使用 super 呼叫。",
        "'{0}.{1}' is inaccessible.": "'{0}.{1}' 無法存取。",
        "'this' cannot be referenced within module bodies.": "您無法在模組主體中參考 'this'。",
        "Invalid '+' expression - types not known to support the addition operator.": "無效的 '+' 運算式。不知道類型因此無法支援加法運算子。",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算術運算右邊的類型必須是 'any'、'number' 或列舉類型。",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算術運算左邊的類型必須是 'any'、'number' 或列舉類型。",
        "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": "一元算術運算的運算元類型必須是 'any'、'number' 或列舉類型。",
        "Variable declarations of a 'for' statement cannot use a type annotation.": "'for' 陳述式的變數宣告不能使用類型註釋。",
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": "'for' 陳述式之變數宣告的類型必須是 'string' 或 'any'。",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "'for...in' 陳述式右邊的類型必須是 'any'、物件類型或類型參數。",
        "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": "'in' 運算式左邊的類型必須是 'any'、'string' 或 'number'。",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": "'in' 運算式右邊的類型必須是 'any'、物件類型或類型參數。",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "'instanceof' 運算式左邊的類型必須是 'any'、物件類型或類型參數。",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "'instanceof' 運算式右邊的類型必須是 'any'，或是可指派給 'Function' 介面類型的類型。",
        "Setters cannot return a value.": "setter 都不能傳回值。",
        "Tried to query type of uninitialized module '{0}'.": "嘗試了查詢未初始化模組 '{0}' 的類型。",
        "Tried to set variable type to uninitialized module type '{0}'.": "已嘗試將變數類型設定為未初始化的模組類型 '{0}'。",
        "Type '{0}' does not have type parameters.": "類型 '{0}' 沒有類型參數。",
        "Getters must return a value.": "getter 必須傳回值。",
        "Getter and setter accessors do not agree in visibility.": "getter 和 setter 存取子的可視性不符。",
        "Invalid left-hand side of assignment expression.": "指派運算式的左邊無效。",
        "Function declared a non-void return type, but has no return expression.": "函式已宣告非 void 的傳回類型，但是沒有傳回運算式。",
        "Cannot resolve return type reference.": "無法解析傳回類型參考。",
        "Constructors cannot have a return type of 'void'.": "建構函式的傳回類型不能是 'void'。",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "後續的變數宣告必須具有相同的類型。變數 '{0}' 的類型必須是 '{1}' 但卻是 '{2}'。",
        "All symbols within a with block will be resolved to 'any'.": "with 區塊中的所有符號都會解析為 'any'。",
        "Import declarations in an internal module cannot reference an external module.": "內部模組中的匯入宣告無法參考外部模組。",
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": "類別 {0} 已宣告介面 {1}，卻未實作該介面:{NL}{2}",
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": "類別 {0} 將類別 {1} 宣告為介面，卻未實作該介面:{NL}{2}",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "遞增或遞減運算子的運算元必須是變數、屬性或索引子。",
        "'this' cannot be referenced in static initializers in a class body.": "無法在類別主體的靜態初始設定式中參考 'this'。",
        "Class '{0}' cannot extend class '{1}':{NL}{2}": "類別 '{0}' 無法擴充類別 '{1}':{NL}{2}",
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": "介面 '{0}' 無法擴充類別 '{1}':{NL}{2}",
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": "介面 '{0}' 無法擴充介面 '{1}':{NL}{2}",
        "Duplicate overload signature for '{0}'.": "'{0}' 的多載呼叫簽章重複。",
        "Duplicate constructor overload signature.": "建構函式多載簽章重複。",
        "Duplicate overload call signature.": "多載呼叫簽章重複。",
        "Duplicate overload construct signature.": "多載建構簽章重複。",
        "Overload signature is not compatible with function definition.": "多載簽章與函式定義不相容。",
        "Overload signature is not compatible with function definition:{NL}{0}": "多載簽章與函式定義不相容:{NL}{0}",
        "Overload signatures must all be public or private.": "多載簽章都必須是公開或私用簽章。",
        "Overload signatures must all be exported or not exported.": "多載簽章必須全部匯出或全部不匯出。",
        "Overload signatures must all be ambient or non-ambient.": "多載簽章都必須是環境或非環境簽章。",
        "Overload signatures must all be optional or required.": "多載簽章都必須是選擇性或必要簽章。",
        "Specialized overload signature is not assignable to any non-specialized signature.": "特製化的多載簽章不可指派給任何非特製化簽章。",
        "'this' cannot be referenced in constructor arguments.": "您無法在建構函式引數中參考 'this'。",
        "Instance member cannot be accessed off a class.": "無法在類別以外存取執行個體成員。",
        "Untyped function calls may not accept type arguments.": "不具類型的函式呼叫無法接受類型引數。",
        "Non-generic functions may not accept type arguments.": "非泛型函式無法接受類型引數。",
        "A generic type may not reference itself with a wrapped form of its own type parameters.": "泛型類型不能使用自身類型參數的包裝形式來參考自己。",
        "Rest parameters must be array types.": "其餘參數的類型必須都是陣列。",
        "Overload signature implementation cannot use specialized type.": "多載簽章實作無法使用特殊類型。",
        "Export assignments may only be used at the top-level of external modules.": "匯出指派只能在最上層的外部模組使用。",
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": "只能使用變數、函式、類別、介面、列舉和內部模組執行匯出指派。",
        "Only public methods of the base class are accessible via the 'super' keyword.": "只有基底類別的公用方法才可以透過 'super' 關鍵字存取。",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.": "數值索引子類型 '{0}' 必須可指派給字串索引子類型 '{1}'。",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}": "數值索引子類型 '{0}' 必須可指派給字串索引子類型 '{1}':{NL}{2}",
        "All numerically named properties must be assignable to numeric indexer type '{0}'.": "所有數值型具名屬性都必須可指派給數值索引子類型 '{0}'。",
        "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}": "所有數值型具名屬性都必須可指派給數值索引子類型 '{0}':{NL}{1}",
        "All named properties must be assignable to string indexer type '{0}'.": "所有具名屬性都必須可指派給字串索引子類型 '{0}'。",
        "All named properties must be assignable to string indexer type '{0}':{NL}{1}": "所有具名屬性都必須可指派給字串索引子類型 '{0}':{NL}{1}",
        "Generic type references must include all type arguments.": "泛型類型參考必須包含所有類型引數。",
        "Default arguments are only allowed in implementation.": "只有實作中才能有預設引數。",
        "Overloads cannot differ only by return type.": "多載不能只根據傳回類型而異。",
        "Function expression declared a non-void return type, but has no return expression.": "函式運算式已宣告非 void 的傳回類型，但是沒有傳回運算式。",
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": "參考到內部模組中識別項的匯入宣告只能搭配變數、函式、類別、介面、列舉和內部模組進行。",
        "Could not find symbol '{0}' in module '{1}'.": "在模組 '{1}' 中找不到符號 '{0}'。",
        "Unable to resolve module reference '{0}'.": "無法解析模組參考 '{0}'。",
        "Could not find module '{0}' in module '{1}'.": "在模組 '{1}' 中找不到模組 '{0}'。",
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": "為匯出的匯入宣告 '{0}' 指派值，但該值的類型具有或使用的是私用類型 '{1}'。",
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": "為匯出的匯入宣告 '{0}' 指派值，但該值的類型使用的是無法存取的模組 '{1}'。",
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": "為匯出的匯入宣告 '{0}' 指派類型，但該類型具有或使用的是私用類型 '{1}'。",
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": "為匯出的匯入宣告 '{0}' 指派類型，但該類型使用的是無法存取的模組 '{1}'。",
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": "為匯出的匯入宣告 '{0}' 指派容器，但該容器是或使用的是無法存取的模組 '{1}'。",
        "Type name '{0}' in extends clause does not reference constructor function for '{1}'.": "extends 子句中的類型名稱 '{0}' 未參考 '{1}' 的建構函式。",
        "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": "匯入宣告中的內部模組參考 '{0}' 未參考 '{1}' 的模組執行個體。",
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": "模組 '{0}' 無法與不同檔案 '{2}' 中 '{1}' 先前的宣告合併。",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": "介面 '{0}' 不能同時擴充類型 '{1}' 和 '{2}':{NL}{3}",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "參數 '{0}' 的初始設定式不能參考在它之後宣告的識別項 '{1}'。",
        "Ambient external module declaration cannot be reopened.": "環境外部模組宣告不可以重新開啟。",
        "All declarations of merged declaration '{0}' must be exported or not exported.": "合併宣告 '{0}' 的所有宣告必須全部匯出或全部不匯出。",
        "'super' cannot be referenced in constructor arguments.": "您無法在建構函式引數中參考 'super'。",
        "Return type of constructor signature must be assignable to the instance type of the class.": "建構函式簽章的傳回類型必須可指派給類別的執行個體類型。",
        "Ambient external module declaration must be defined in global context.": "環境外部模組宣告必須在全域內容中定義。",
        "Ambient external module declaration cannot specify relative module name.": "環境外部模組宣告不能指定相對模組名稱。",
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": "環境外部模組宣告中的匯入宣告不能透過相對外部模組名稱參考外部模組。",
        "Could not find the best common type of types of all return statement expressions.": "在所有傳回陳述式運算式的類型中，找不到最佳一般類型。",
        "Import declaration cannot refer to external module reference when --noResolve option is set.": "在已設定 --noResolve 選項的情況下，匯入宣告不能參考外部模組參考。",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "識別項 '_this' 重複。編譯器使用變數宣告 '_this' 來擷取 'this' 參考。",
        "'continue' statement can only be used within an enclosing iteration statement.": "'continue' 陳述式只能用在封入的反覆項目陳述式內。",
        "'break' statement can only be used within an enclosing iteration or switch statement.": "'break' 陳述式只能用在封入的反覆項目或 switch 陳述式內。",
        "Jump target not found.": "找不到跳躍目標。",
        "Jump target cannot cross function boundary.": "跳躍目標不能跨越函式界限。",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "識別項 '_super' 重複。編譯器使用 '_super' 來擷取基底類別參考。",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "運算式解析成編譯器用來擷取 'this' 參考的變數宣告 '_this'。",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "運算式解析成編譯器用來擷取基底類別參考的 '_super'。",
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "匯出介面之建構函式簽章的 TypeParameter '{0}' 已經或正在使用私用類型 '{1}'。",
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "匯出介面之呼叫簽章的 TypeParameter '{0}' 已經或正在使用私用類型 '{1}'。",
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": "匯出類別之公用靜態方法的 TypeParameter '{0}' 已經或正在使用私用類型 '{1}'。",
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": "匯出類別之公用方法的 TypeParameter '{0}' 已經或正在使用私用類型 '{1}'。",
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": "匯出介面之方法的 TypeParameter '{0}' 已經或正在使用私用類型 '{1}'。",
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": "匯出函式的 TypeParameter '{0}' 已經或正在使用私用類型 '{1}'。",
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "匯出介面之建構函式簽章的 TypeParameter '{0}' 正在使用無法存取的模組 {1}。",
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": "匯出介面之呼叫簽章的 TypeParameter '{0}' 正在使用無法存取的模組 {1}",
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": "匯出類別之公用靜態方法的 TypeParameter '{0}' 正在使用無法存取的模組 {1}。",
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": "匯出類別之公用方法的 TypeParameter '{0}' 正在使用無法存取的模組 {1}。",
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": "匯出介面之方法的 TypeParameter '{0}' 正在使用無法存取的模組 {1}。",
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": "匯出函式的 TypeParameter '{0}' 正在使用無法存取的模組 {1}。",
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": "匯出類別的 TypeParameter '{0}' 已經或正在使用私用類型 '{1}'。",
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": "匯出介面的 TypeParameter '{0}' 已經或正在使用私用類型 '{1}'。",
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": "匯出類別的 TypeParameter '{0}' 正在使用無法存取的模組 {1}。",
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": "匯出介面的 TypeParameter '{0}' 正在使用無法存取的模組 {1}。",
        "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": "識別項 '_i' 重複。編譯器使用 '_i' 來初始化剩餘參數。",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "識別項 'arguments'' 重複。編譯器使用 'arguments' 來初始化剩餘參數。",
        "Type of conditional '{0}' must be identical to '{1}' or '{2}'.": "條件式 '{0}' 的類型必須與 '{1}' 或 '{2}' 相同。",
        "Type of conditional '{0}' must be identical to '{1}', '{2}' or '{3}'.": "條件式 '{0}' 的類型必須與 '{1}'、'{2}' 或 '{3}' 相同。",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": "識別項 '{0}' 重複。編譯器將名稱 '{1}' 保留在外部模組的最上層範圍。",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "類型參數的條件約束不能參考相同類型參數清單中的任何類型參數。",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "執行個體成員變數 '{0}' 的初始設定式不能參考建構函式中宣告的識別項 '{1}'。",
        "Parameter '{0}' cannot be referenced in its initializer.": "無法在參數 '{0}' 的初始設定式中參考此參數。",
        "Duplicate string index signature.": "字串索引簽章重複。",
        "Duplicate number index signature.": "數字索引簽章重複。",
        "All declarations of an interface must have identical type parameters.": "介面的所有宣告必須具有相同的類型參數。",
        "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.": "運算式解析成編譯器用來初始化剩餘參數的變數宣告 '_i'。",
        "Type '{0}' is missing property '{1}' from type '{2}'.": "類型 '{0}' 遺漏類型 '{2}' 的屬性 '{1}'。",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": "類型 '{1}' 和 '{2}' 之屬性 '{0}' 的類型不相容。",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": "類型 '{1}' 和 '{2}' 之屬性 '{0}' 的類型不相容:{NL}{3}",
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "在類型 '{1}' 中定義為私用的屬性 '{0}' 在類型 '{2}' 中卻定義為公用。",
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "在類型 '{1}' 中定義為公用的屬性 '{0}' 在類型 '{2}' 中卻定義為私用。",
        "Types '{0}' and '{1}' define property '{2}' as private.": "類型 '{0}' 和 '{1}' 將屬性 '{2}' 定義為私用。",
        "Call signatures of types '{0}' and '{1}' are incompatible.": "類型為 '{0}' 和 '{1}' 的呼叫簽章不相容。",
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "類型為 '{0}' 和 '{1}' 的呼叫簽章不相容:{NL}{2}",
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": "類型 '{0}' 需要呼叫簽章，但是類型 '{1}' 則缺少此簽章。",
        "Construct signatures of types '{0}' and '{1}' are incompatible.": "類型為 '{0}' 和 '{1}' 的建構簽章不相容。",
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "類型為 '{0}' 和 '{1}' 的建構簽章不相容:{NL}{2}",
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": "類型 '{0}' 需要建構函式簽章，但是類型 '{1}' 則缺少此簽章。",
        "Index signatures of types '{0}' and '{1}' are incompatible.": "類型為 '{0}' 和 '{1}' 的索引簽章不相容。",
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "類型為 '{0}' 和 '{1}' 的索引簽章不相容:{NL}{2}",
        "Call signature expects {0} or fewer parameters.": "呼叫簽章需要 {0} 個或更少參數。",
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": "無法將類型 '{0}' 套用至類型為 '{2}' 的引數 {1}。",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "類別 '{0}' 已定義執行個體成員存取子 '{1}'，但是擴充類別 '{2}' 卻將其定義為執行個體成員函式。",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "類別 '{0}' 已定義執行個體成員屬性 '{1}'，但是擴充類別 '{2}' 卻將其定義為執行個體成員函式。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "類別 '{0}' 已定義執行個體成員函式 '{1}'，但是擴充類別 '{2}' 卻將其定義為執行個體成員存取子。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "類別 '{0}' 已定義執行個體成員函式 '{1}'，但是擴充類別 '{2}' 卻將其定義為執行個體成員屬性。",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": "類別 '{1}' 和 '{2}' 之靜態屬性 '{0}' 的類型不相容。",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": "類別 '{1}' 和 '{2}' 之靜態屬性 '{0}' 的類型不相容:{NL}{3}",
        "Type reference cannot refer to container '{0}'.": "類型參考不能參考容器 '{0}'。",
        "Type reference must refer to type.": "類型參考必須參考類型。",
        "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.": "在具有多重宣告的列舉中，只有一個宣告可以省略第一個列舉元素的初始設定式。",
        " (+ {0} overload(s))": " (+ {0} 個多載)",
        "Variable declaration cannot have the same name as an import declaration.": "變數宣告不能與匯入宣告同名。",
        "Signature expected {0} type arguments, got {1} instead.": "簽章需要 {0} 個類型引數，卻收到 {1} 個。",
        "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": "屬性 '{0}' 在類型 '{1}' 中定義為選擇性屬性，但在類型 '{2}' 中卻是必要屬性。",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.": "來自無限擴充類型參考的類型 '{0}' 和 '{1}' 未參考相同的具名類型。",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.": "來自無限擴充類型參考的類型 '{0}' 和 '{1}' 具有不相容的類型引數。",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}": "來自無限擴充類型參考的類型 '{0}' 和 '{1}' 具有不相容的類型引數:{NL}{2}",
        "Named properties '{0}' of types '{1}' and '{2}' are not identical.": "類型 '{1}' 與 '{2}' 的具名屬性 '{0}' 不相同。",
        "Types of string indexer of types '{0}' and '{1}' are not identical.": "類型 '{0}' 與 '{1}' 的字串索引子的類型不相容。",
        "Types of number indexer of types '{0}' and '{1}' are not identical.": "類型 '{0}' 與 '{1}' 的數字索引子的類型不相容。",
        "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}": "類型 '{0}' 中數值索引子的類型不可指派給類型 '{1}' 中的字串索引子類型。{NL}{2}",
        "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}": "類型 '{1}' 中屬性 '{0}' 的類型不可指派給類型 '{2}' 中的字串索引子類型。{NL}{3}",
        "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}": "類型 '{1}' 中屬性 '{0}' 的類型不可指派給類型 '{2}' 中的數值索引子類型。{NL}{3}",
        "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "靜態屬性 '{0}' 在類型 '{1}' 中定義為私用屬性，但在類型 '{2}' 中卻定義公用屬性。",
        "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "靜態屬性 '{0}' 在類型 '{1}' 中定義為公用屬性，但在類型 '{2}' 中卻定義私用屬性。",
        "Types '{0}' and '{1}' define static property '{2}' as private.": "類型 '{0}' 和 '{1}' 將靜態屬性 '{2}' 定義為私用。",
        "Current host does not support '{0}' option.": "目前的主機不支援 '{0}' 選項。",
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": "不支援 ECMAScript 目標版本 '{0}'。請指定有效的目標版本: '{1}' (預設)，或 '{2}'",
        "Module code generation '{0}' not supported.": "不支援模組程式碼產生 '{0}'。",
        "Could not find file: '{0}'.": "找不到檔案: '{0}'。",
        "A file cannot have a reference to itself.": "檔案不能參考自己。",
        "Cannot resolve referenced file: '{0}'.": "無法解析被參考的檔案: '{0}'。",
        "Cannot find the common subdirectory path for the input files.": "找不到輸入檔案的一般子目錄路徑。",
        "Emit Error: {0}.": "發出錯誤: {0}。",
        "Cannot read file '{0}': {1}": "無法讀取檔案 '{0}': {1}",
        "Unsupported file encoding.": "不支援的檔案編碼。",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "地區設定的形式必須是 <language> 或 <language>-<territory>。例如 '{0}' 或 '{1}'。",
        "Unsupported locale: '{0}'.": "不支援的地區設定: '{0}'。",
        "Execution Failed.{NL}": "執行錯誤。{NL}",
        "Invalid call to 'up'": "無效的 'up' 呼叫",
        "Invalid call to 'down'": "無效的 'down' 呼叫",
        "Base64 value '{0}' finished with a continuation bit.": "Base64 值 '{0}' 以連續位元做為結束。",
        "Unknown option '{0}'": "未知的選項 '{0}'",
        "Expected {0} arguments to message, got {1} instead.": "訊息必須有 {0} 個引數，卻收到 {1} 個。",
        "Expected the message '{0}' to have {1} arguments, but it had {2}": "訊息 '{0}' 必須有 {1} 個引數，但卻有 {2} 個",
        "Could not delete file '{0}'": "無法刪除檔案 '{0}'",
        "Could not create directory '{0}'": "無法建立目錄 '{0}'",
        "Error while executing file '{0}': ": "執行檔案 '{0}' 時發生錯誤: ",
        "Cannot compile external modules unless the '--module' flag is provided.": "除非提供 '--module' 旗標，否則無法編譯外部模組。",
        "Option mapRoot cannot be specified without specifying sourcemap option.": "必須指定 sourcemap 選項才能指定 mapRoot 選項。",
        "Option sourceRoot cannot be specified without specifying sourcemap option.": "必須指定 sourcemap 選項才能指定 sourceRoot 選項。",
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": "必須指定 sourcemap 選項才能指定 mapRoot 和 sourceRoot 選項。",
        "Option '{0}' specified without '{1}'": "指定了選項 '{0}'，卻沒有 '{1}'",
        "'codepage' option not supported on current platform.": "目前平台不支援 'codepage' 選項。",
        "Concatenate and emit output to single file.": "串連並發出輸出至單一檔案。",
        "Generates corresponding {0} file.": "產生對應的 {0} 檔案。",
        "Specifies the location where debugger should locate map files instead of generated locations.": "指定偵錯工具尋找對應檔的位置，而不尋找產生的位置。",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "指定偵錯工具尋找 TypeScript 檔案的位置，而不尋找原始檔位置。",
        "Watch input files.": "監看輸入檔案。",
        "Redirect output structure to the directory.": "將輸出結構重新導向至目錄。",
        "Do not emit comments to output.": "不將註解發出到輸出。",
        "Skip resolution and preprocessing.": "略過解析和前置處理。",
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": "指定 ECMAScript 目標版本: '{0}' (預設)，或 '{1}'",
        "Specify module code generation: '{0}' or '{1}'": "指定模組程式碼產生: '{0}' 或 '{1}'",
        "Print this message.": "列印這個訊息。",
        "Print the compiler's version: {0}": "列印編譯器的版本: {0}",
        "Allow use of deprecated '{0}' keyword when referencing an external module.": "參考外部模組時，允許使用已被取代的 '{0}' 關鍵字。",
        "Specify locale for errors and messages. For example '{0}' or '{1}'": "指定錯誤和訊息的地區設定。例如 '{0}' 或 '{1}'",
        "Syntax:   {0}": "語法: {0}",
        "options": "選項",
        "file1": "檔案",
        "Examples:": "範例:",
        "Options:": "選項:",
        "Insert command line options and files from a file.": "從檔案插入命令列選項和檔案。",
        "Version {0}": "版本 {0}",
        "Use the '{0}' flag to see options.": "使用 '{0}' 旗標查看選項。",
        "{NL}Recompiling ({0}):": "{NL}正在重新編譯 ({0}):",
        "STRING": "STRING",
        "KIND": "KIND",
        "file2": "檔案",
        "VERSION": "VERSION",
        "LOCATION": "位置",
        "DIRECTORY": "目錄",
        "NUMBER": "數字",
        "Specify the codepage to use when opening source files.": "指定開啟原始程式檔時所要使用的字碼頁。",
        "Additional locations:": "其他位置:",
        "This version of the Javascript runtime does not support the '{0}' function.": "這個 Javascript 執行階段版本不支援 '{0}' 函式。",
        "Unknown rule.": "未知的規則。",
        "Invalid line number ({0})": "無效的行號 ({0})",
        "Warn on expressions and declarations with an implied 'any' type.": "針對具隱含之 'any' 類型的運算式和宣告產生警告。",
        "Variable '{0}' implicitly has an 'any' type.": "變數 '{0}' 隱含具有 'any' 類型。",
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": "'{1}' 的參數 '{0}' 隱含具有 'any' 類型。",
        "Parameter '{0}' of function type implicitly has an 'any' type.": "函式類型的參數 '{0}' 隱含具有 'any' 類型。",
        "Member '{0}' of object type implicitly has an 'any' type.": "物件類型的成員 '{0}' 隱含具有 'any' 類型。",
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": "缺少建構函式簽章的 'new' 運算式隱含具有 'any' 類型。",
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": "缺少傳回類型註釋的 '{0}' 隱含具有 'any' 傳回類型。",
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少傳回類型註釋的函式運算式隱含具有 'any' 傳回類型。",
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": "lambda 函式的參數 '{0}' 隱含具有 'any' 類型。",
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少傳回類型註釋的建構函式簽章隱含具有 'any' 傳回類型。",
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": "缺少傳回類型註釋的 Lambda 函式隱含具有 'any' 傳回類型。",
        "Array Literal implicitly has an 'any' type from widening.": "陣列常值隱含具有擴展來的 'any' 類型。",
        "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": "缺少 'get' 存取子和 'set' 存取子參數類型註釋的 '{0}' 隱含具有 'any' 類型。",
        "Index signature of object type implicitly has an 'any' type.": "物件類型的索引簽章隱含具有 'any' 類型。",
        "Object literal's property '{0}' implicitly has an 'any' type from widening.": "物件常值的屬性 '{0}' 隱含具有擴展來的 'any' 類型。"
}