{
        "error TS{0}: {1}": "エラー TS{0}: {1}",
        "warning TS{0}: {1}": "警告 TS{0}: {1}",
        "Unrecognized escape sequence.": "認識できないエスケープ シーケンスです。",
        "Unexpected character {0}.": "文字 {0} は予期されていません。",
        "Missing close quote character.": "閉じ二重引用符がありません。",
        "Identifier expected.": "識別子が必要です。",
        "'{0}' keyword expected.": "'{0}' キーワードが必要です。",
        "'{0}' expected.": "'{0}' が必要です。",
        "Identifier expected; '{0}' is a keyword.": "識別子が必要です。'{0}' はキーワードです。",
        "Automatic semicolon insertion not allowed.": "セミコロンの自動挿入は使用できません。",
        "Unexpected token; '{0}' expected.": "予期しないトークンです。予期されるトークンは '{0}' です。",
        "Trailing separator not allowed.": "末尾の区切り記号は使用できません。",
        "'*/' expected.": "'*/' が必要です。",
        "'public' or 'private' modifier must precede 'static'.": "'public' 修飾子または 'private' 修飾子は 'static' の前に指定しなければなりません。",
        "Unexpected token.": "予期しないトークンです。",
        "Catch clause parameter cannot have a type annotation.": "catch 句のパラメーターに型の注釈を指定することはできません。",
        "Rest parameter must be last in list.": "rest パラメーターはリストの最後に指定する必要があります。",
        "Parameter cannot have question mark and initializer.": "パラメーターに疑問符および初期化子を指定することはできません。",
        "Required parameter cannot follow optional parameter.": "必須パラメーターを省略可能なパラメーターの後に指定することはできません。",
        "Index signatures cannot have rest parameters.": "インデックス シグネチャに rest パラメーターを指定することはできません。",
        "Index signature parameter cannot have accessibility modifiers.": "インデックス シグネチャのパラメーターにアクセシビリティ修飾子を指定することはできません。",
        "Index signature parameter cannot have a question mark.": "インデックス シグネチャのパラメーターに疑問符を指定することはできません。",
        "Index signature parameter cannot have an initializer.": "インデックス シグネチャのパラメーターに初期化子を指定することはできません。",
        "Index signature must have a type annotation.": "インデックス シグネチャには型のコメントが必要です。",
        "Index signature parameter must have a type annotation.": "インデックス シグネチャのパラメーターには型のコメントが必要です。",
        "Index signature parameter type must be 'string' or 'number'.": "インデックス シグネチャのパラメーターの型は 'string' または 'number' でなければなりません。",
        "'extends' clause already seen.": "'extends' 句は既に存在します。",
        "'extends' clause must precede 'implements' clause.": "'extends' 句は 'implements' 句の前に指定しなければなりません。",
        "Classes can only extend a single class.": "クラスで拡張できるのは単一のクラスだけです。",
        "'implements' clause already seen.": "'implements' 句は既に存在します。",
        "Accessibility modifier already seen.": "アクセシビリティ修飾子は既に存在します。",
        "'{0}' modifier must precede '{1}' modifier.": "'{0}' 修飾子は '{1}' 修飾子の前に指定する必要があります。",
        "'{0}' modifier already seen.": "'{0}' 修飾子は既に存在します。",
        "'{0}' modifier cannot appear on a class element.": "'{0}' 修飾子はクラス要素では使用できません。",
        "Interface declaration cannot have 'implements' clause.": "インターフェイスの宣言に 'implements' 句を含めることはできません。",
        "'super' invocation cannot have type arguments.": "'super' の呼び出しで型引数を指定することはできません。",
        "Only ambient modules can use quoted names.": "引用符付きの名前を使用できるのはアンビエント モジュールのみです。",
        "Statements are not allowed in ambient contexts.": "ステートメントはアンビエント コンテキストでは使用できません。",
        "Implementations are not allowed in ambient contexts.": "実装はアンビエント コンテキストでは使用できません。",
        "'declare' modifier not allowed for code already in an ambient context.": "'declare' 修飾子はアンビエント コンテキストのコードでは使用できません。",
        "Initializers are not allowed in ambient contexts.": "初期化子はアンビエント コンテキストでは使用できません。",
        "Parameter property declarations can only be used in a non-ambient constructor declaration.": "パラメーター プロパティの宣言はアンビエントではないコンストラクター宣言でのみ使用できます。",
        "Function implementation expected.": "関数の実装が必要です。",
        "Constructor implementation expected.": "コンストラクターの実装が必要です。",
        "Function overload name must be '{0}'.": "関数のオーバーロードの名前は '{0}' でなければなりません。",
        "'{0}' modifier cannot appear on a module element.": "'{0}' 修飾子はモジュール要素では使用できません。",
        "'declare' modifier cannot appear on an interface declaration.": "'declare' 修飾子はインターフェイス宣言では使用できません。",
        "'declare' modifier required for top level element.": "最上位の要素に 'declare' 修飾子が必要です。",
        "Rest parameter cannot be optional.": "rest パラメーターを省略可能にすることはできません。",
        "Rest parameter cannot have an initializer.": "rest パラメーターに初期化子を指定することはできません。",
        "'set' accessor must have one and only one parameter.": "'set' アクセサーにはパラメーターを 1 つだけ指定する必要があります。",
        "'set' accessor parameter cannot be optional.": "'set' アクセサーのパラメーターを省略可能にすることはできません。",
        "'set' accessor parameter cannot have an initializer.": "'set' アクセサーのパラメーターに初期化子を指定することはできません。",
        "'set' accessor cannot have rest parameter.": "'set' アクセサーに rest パラメーターを指定することはできません。",
        "'get' accessor cannot have parameters.": "'get' アクセサーにパラメーターを指定することはできません。",
        "Modifiers cannot appear here.": "修飾子はここでは使用できません。",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "アクセサーは ECMAScript 5 以上をターゲットにする場合にのみ使用できます。",
        "Class name cannot be '{0}'.": "クラスの名前を '{0}' にすることはできません。",
        "Interface name cannot be '{0}'.": "インターフェイスの名前を '{0}' にすることはできません。",
        "Enum name cannot be '{0}'.": "列挙の名前を '{0}' にすることはできません。",
        "Module name cannot be '{0}'.": "モジュールの名前を '{0}' にすることはできません。",
        "Enum member must have initializer.": "列挙メンバーには初期化子が必要です。",
        "Export assignment cannot be used in internal modules.": "エクスポートの割り当ては、内部モジュールでは使用できません。",
        "Export assignment not allowed in module with exported element.": "エクスポートの割り当ては、エクスポートされた要素を含むモジュールでは使用できません。",
        "Module cannot have multiple export assignments.": "モジュールにエクスポートの割り当てを複数含めることはできません。",
        "Ambient enum elements can only have integer literal initializers.": "アンビエント列挙要素には整数リテラル初期化子のみを指定できます。",
        "module, class, interface, enum, import or statement": "モジュール、クラス、インターフェイス、列挙、インポート、またはステートメント",
        "constructor, function, accessor or variable": "コンストラクター、関数、アクセサー、または変数",
        "statement": "ステートメント",
        "case or default clause": "case または既定の句",
        "identifier": "識別子",
        "call, construct, index, property or function signature": "呼び出し、コンストラクト、インデックス、プロパティ、または関数のシグネチャ",
        "expression": "式",
        "type name": "型名",
        "property or accessor": "プロパティまたはアクセサー",
        "parameter": "パラメーター",
        "type": "型",
        "type parameter": "型パラメーター",
        "'declare' modifier not allowed on import declaration.": "修飾子 'declare' は、インポートの宣言では使用できません。",
        "Function overload must be static.": "関数のオーバーロードは静的でなければなりません。",
        "Function overload must not be static.": "関数のオーバーロードは静的にはできせん。",
        "Parameter property declarations cannot be used in a constructor overload.": "パラメーター プロパティの宣言はコンストラクターのオーバーロードで使用できません。",
        "Invalid 'reference' directive syntax.": "無効な 'reference' ディレクティブ構文です。",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "octal リテラルは ECMAScript 5 以上をターゲットにする場合には使用できません。",
        "Accessors are not allowed in ambient contexts.": "アクセサーはアンビエント コンテキストでは使用できません。",
        "'{0}' modifier cannot appear on a constructor declaration.": "'{0}' 修飾子はコンストラクター宣言では使用できません。",
        "'{0}' modifier cannot appear on a parameter.": "'{0}' 修飾子はパラメーターでは使用できません。",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "'for...in' ステートメントでは 1 つの変数宣言のみが使用できます。",
        "Type parameters cannot appear on a constructor declaration.": "型パラメーターはコンストラクター宣言では使用できません。",
        "Type annotation cannot appear on a constructor declaration.": "型の注釈はコンストラクター宣言では使用できません。",
        "Duplicate identifier '{0}'.": "識別子 '{0}' が重複しています。",
        "The name '{0}' does not exist in the current scope.": "名前 '{0}' が現在のスコープに存在しません。",
        "The name '{0}' does not refer to a value.": "名前 '{0}' が値を参照していません。",
        "'super' can only be used inside a class instance method.": "'super' はクラス インスタンス メソッドの内部でのみ使用できます。",
        "The left-hand side of an assignment expression must be a variable, property or indexer.": "代入式の左辺には、変数、プロパティ、またはインデクサーを指定してください。",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "型 '{0}' の値を呼び出すことはできません。'new' を含めますか?",
        "Value of type '{0}' is not callable.": "型 '{0}' の値を呼び出すことはできません。",
        "Value of type '{0}' is not newable.": "型 '{0}' の値を更新することはできません。",
        "Value of type '{0}' is not indexable by type '{1}'.": "型 '{0}' の値を型 '{1}' でインデックスすることはできません。",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "操作 '{0}' を型 '{1}' および '{2}' に適用することはできません。",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": "操作 '{0}' を型 '{1}' および '{2}' に適用することはできません: {3}",
        "Cannot convert '{0}' to '{1}'.": "'{0}' を '{1}' に変換できません。",
        "Cannot convert '{0}' to '{1}':{NL}{2}": "{0} を {1} に変換できません: {NL}{2}",
        "Expected var, class, interface, or module.": "変数、クラス、インターフェイス、またはモジュールが必要です。",
        "Operator '{0}' cannot be applied to type '{1}'.": "操作 '{0}' を型 '{1}' に適用することはできません。",
        "Getter '{0}' already declared.": "get アクセス操作子 '{0}' は既に宣言されています。",
        "Setter '{0}' already declared.": "set アクセス操作子 '{0}' は既に宣言されています。",
        "Exported class '{0}' extends private class '{1}'.": "エクスポートされたクラス '{0}' に、プライベート クラス '{1}' の拡張が含まれています。",
        "Exported class '{0}' implements private interface '{1}'.": "エクスポートされたクラス '{0}' に、プライベート インターフェイス '{1}' の実装が含まれています。",
        "Exported interface '{0}' extends private interface '{1}'.": "エクスポートされたインターフェイス '{0}' に、プライベート インターフェイス '{1}' の拡張が含まれています。",
        "Exported class '{0}' extends class from inaccessible module {1}.": "エクスポートされたクラス '{0}' に、アクセスできないモジュール {1} のクラスの拡張が含まれています。",
        "Exported class '{0}' implements interface from inaccessible module {1}.": "エクスポートされたクラス '{0}' に、アクセスできないモジュール {1} のインターフェイスの実装が含まれています。",
        "Exported interface '{0}' extends interface from inaccessible module {1}.": "エクスポートされたインターフェイス '{0}' に、アクセスできないモジュール {1} のインターフェイスの拡張が含まれています。",
        "Public static property '{0}' of exported class has or is using private type '{1}'.": "エクスポートされたクラスのパブリック静的プロパティ '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Public property '{0}' of exported class has or is using private type '{1}'.": "エクスポートされたクラスのパブリック プロパティ '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Property '{0}' of exported interface has or is using private type '{1}'.": "エクスポートされたインターフェイスのプロパティ '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Exported variable '{0}' has or is using private type '{1}'.": "エクスポートされた変数 '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Public static property '{0}' of exported class is using inaccessible module {1}.": "エクスポートされたクラスのパブリック静的プロパティ '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Public property '{0}' of exported class is using inaccessible module {1}.": "エクスポートされたクラスのパブリック プロパティ '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Property '{0}' of exported interface is using inaccessible module {1}.": "エクスポートされたインターフェイスのプロパティ '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Exported variable '{0}' is using inaccessible module {1}.": "エクスポートされた変数 '{0}' で、アクセスできないモジュール '{1}' が使用されています。",
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": "エクスポートされたクラスのコンストラクターのパラメーター '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": "エクスポートされたクラスのパブリック静的プロパティ set アクセス操作子のパラメーター '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": "エクスポートされたクラスのパブリック プロパティ set アクセス操作子のパラメーター '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "エクスポートされたインターフェイスのコンストラクター シグネチャのパラメーター '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "エクスポートされたインターフェイスの呼び出しシグネチャのパラメーター '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": "エクスポートされたクラスのパブリック静的メソッドのパラメーター '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": "エクスポートされたクラスのパブリック メソッドのパラメーター '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": "エクスポートされたインターフェイスのメソッドのパラメーター '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Parameter '{0}' of exported function has or is using private type '{1}'.": "エクスポートされた関数のパラメーター '{0}' で、プライベート型 '{1}' が指定されているか使用されています。",
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": "エクスポートされたクラスのコンストラクターのパラメーター '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": "エクスポートされたクラスのパブリック静的プロパティ set アクセス操作子のパラメーター '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": "エクスポートされたクラスのパブリック プロパティ set アクセス操作子のパラメーター '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "エクスポートされたインターフェイスのコンストラクター シグネチャのパラメーター '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": "エクスポートされたインターフェイスの呼び出しシグネチャのパラメーター '{0}' で、アクセスできないモジュール {1} が使用されています",
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": "エクスポートされたクラスのパブリック静的メソッドのパラメーター '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": "エクスポートされたクラスのパブリック メソッドのパラメーター '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": "エクスポートされたインターフェイスのメソッドのパラメーター '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Parameter '{0}' of exported function is using inaccessible module {1}.": "エクスポートされた関数のパラメーター '{0}' で、アクセスできないモジュール {1} が使用されています。",
        "Return type of public static property getter from exported class has or is using private type '{0}'.": "エクスポートされたクラスのパブリック静的プロパティ get アクセス操作子の戻り値の型で、プライベート型 '{0}' が指定されているか使用されています。",
        "Return type of public property getter from exported class has or is using private type '{0}'.": "エクスポートされたクラスのパブリック プロパティ get アクセス操作子の戻り値の型で、プライベート型 '{0}' が指定されているか使用されています。",
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": "エクスポートされたインターフェイスのコンストラクター シグネチャの戻り値の型で、プライベート型 '{0}' が指定されているか使用されています。",
        "Return type of call signature from exported interface has or is using private type '{0}'.": "エクスポートされたインターフェイスの呼び出しシグネチャの戻り値の型で、プライベート型 '{0}' が指定されているか使用されています。",
        "Return type of index signature from exported interface has or is using private type '{0}'.": "エクスポートされたインターフェイスのインデックス シグネチャの戻り値の型で、プライベート型 '{0}' が指定されているか使用されています。",
        "Return type of public static method from exported class has or is using private type '{0}'.": "エクスポートされたクラスのパブリック静的メソッドの戻り値の型で、プライベート型 '{0}' が指定されているか使用されています。",
        "Return type of public method from exported class has or is using private type '{0}'.": "エクスポートされたクラスのパブリック メソッドの戻り値の型で、プライベート型 '{0}' が指定されているか使用されています。",
        "Return type of method from exported interface has or is using private type '{0}'.": "エクスポートされたインターフェイスのメソッドの戻り値の型で、プライベート型 '{0}' が指定されているか使用されています。",
        "Return type of exported function has or is using private type '{0}'.": "エクスポートされた関数の戻り値の型で、プライベート型 '{0}' が指定されているか使用されています。",
        "Return type of public static property getter from exported class is using inaccessible module {0}.": "エクスポートされたクラスのパブリック静的プロパティ get アクセス操作子の戻り値の型で、アクセスできないモジュール {0} が使用されています。",
        "Return type of public property getter from exported class is using inaccessible module {0}.": "エクスポートされたクラスのパブリック プロパティ get アクセス操作子の戻り値の型で、アクセスできないモジュール {0} が使用されています。",
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": "エクスポートされたインターフェイスのコンストラクター シグネチャの戻り値の型で、アクセスできないモジュール {0} が使用されています。",
        "Return type of call signature from exported interface is using inaccessible module {0}.": "エクスポートされたインターフェイスの呼び出しシグネチャの戻り値の型で、アクセスできないモジュール {0} が使用されています。",
        "Return type of index signature from exported interface is using inaccessible module {0}.": "エクスポートされたインターフェイスのインデックス シグネチャの戻り値の型で、アクセスできないモジュール {0} が使用されています。",
        "Return type of public static method from exported class is using inaccessible module {0}.": "エクスポートされたクラスのパブリック静的メソッドの戻り値の型で、アクセスできないモジュール {0} が使用されています。",
        "Return type of public method from exported class is using inaccessible module {0}.": "エクスポートされたクラスのパブリック メソッドの戻り値の型で、アクセスできないモジュール {0} が使用されています。",
        "Return type of method from exported interface is using inaccessible module {0}.": "エクスポートされたインターフェイスのメソッドの戻り値の型で、アクセスできないモジュール {0} が使用されています。",
        "Return type of exported function is using inaccessible module {0}.": "エクスポートされた関数の戻り値の型で、アクセスできないモジュール {0} が使用されています。",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "'new T[]' は配列の作成に使用できません。代わりに 'new Array<T>()' を使用してください。",
        "A parameter list must follow a generic type argument list. '(' expected.": "パラメーター リストはジェネリック型の引数リストの後に記述する必要があります。'(' が必要です。",
        "Multiple constructor implementations are not allowed.": "コンストラクターを複数実装することはできません。",
        "Unable to resolve external module '{0}'.": "外部モジュール '{0}' を解決できません。",
        "Module cannot be aliased to a non-module type.": "モジュールにモジュール以外の種類のエイリアスを設定することはできません。",
        "A class may only extend another class.": "クラスで拡張できるのは別のクラスだけです。",
        "A class may only implement another class or interface.": "クラスで実装できるのは別のクラスまたはインターフェイスだけです。",
        "An interface may only extend another class or interface.": "インターフェイスで拡張できるのは別のクラスまたはインターフェイスだけです。",
        "Unable to resolve type.": "型を解決できません。",
        "Unable to resolve type of '{0}'.": "'{0}' の型を解決できません。",
        "Unable to resolve type parameter constraint.": "型パラメーター制約を解決できません。",
        "Type parameter constraint cannot be a primitive type.": "型パラメーターの制約をプリミティブ型にすることはできません。",
        "Supplied parameters do not match any signature of call target.": "指定されたパラメーターが呼び出し対象のどのシグネチャとも一致しません。",
        "Supplied parameters do not match any signature of call target:{NL}{0}": "指定されたパラメーターが呼び出し対象のどのシグネチャとも一致しません: {NL}{0}",
        "Invalid 'new' expression.": "'new' 式が無効です。",
        "Call signatures used in a 'new' expression must have a 'void' return type.": "'new' 式で使用される呼び出しシグネチャの戻り値の型は 'void' でなければなりません。",
        "Could not select overload for 'new' expression.": "'new' 式に対するオーバーロードを選択できません。",
        "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": "型 '{0}' は型パラメーター '{2}' の制約 '{1}' を満たしていません。",
        "Could not select overload for 'call' expression.": "'call' 式に対するオーバーロードを選択できません。",
        "Cannot invoke an expression whose type lacks a call signature.": "型に呼び出しシグネチャがない式を呼び出すことはできません。",
        "Calls to 'super' are only valid inside a class.": "'super' の呼び出しはクラス内でのみ有効です。",
        "Generic type '{0}' requires {1} type argument(s).": "ジェネリック型 '{0}' には {1} 個の型引数が必要です。",
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": "配列リテラルの型を特定できません。配列要素に最適な共通型が見つかりません。",
        "Could not find enclosing symbol for dotted name '{0}'.": "ドット形式の名前 '{0}' を囲むシンボルが見つかりません。",
        "The property '{0}' does not exist on value of type '{1}'.": "プロパティ '{0}' は型 '{1}' の値に存在しません。",
        "Could not find symbol '{0}'.": "シンボル '{0}' が見つかりません。",
        "'get' and 'set' accessor must have the same type.": "'get' アクセサーと 'set' アクセサーは同じ型でなければなりません。",
        "'this' cannot be referenced in current location.": "'this' は現在の場所では参照できません。",
        "Static members cannot reference class type parameters.": "静的メンバーはクラスの型パラメーターを参照できません。",
        "Class '{0}' is recursively referenced as a base type of itself.": "クラス '{0}' がそれ自体の基本型として再帰的に参照されています。",
        "Interface '{0}' is recursively referenced as a base type of itself.": "インターフェイス '{0}' がそれ自体の基本型として再帰的に参照されています。",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "'super' プロパティ アクセスはコンストラクター、メンバー関数、または派生クラスのメンバー アクセサーでのみ許可されます。",
        "'super' cannot be referenced in non-derived classes.": "'super' は派生クラス以外では参照できません。",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "'super' の呼び出しは、初期化されたプロパティまたはパラメーターのプロパティがクラスに含まれている場合、コンストラクターの最初のステートメントでなければなりません。",
        "Constructors for derived classes must contain a 'super' call.": "派生クラスのコンストラクターには 'super' の呼び出しを含める必要があります。",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "super の呼び出しは、コンストラクターの外部、またはコンストラクター内の入れ子になった関数では使用できません。",
        "'{0}.{1}' is inaccessible.": "'{0}.{1}' にアクセスできません。",
        "'this' cannot be referenced within module bodies.": "'this' はモジュール本体の内部では参照できません。",
        "Invalid '+' expression - types not known to support the addition operator.": "'+' 式が無効です。加算演算子がサポートされていない型である可能性があります。",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算術演算の右辺には、'any' 型、'number' 型、または列挙型を指定してください。",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "算術演算の左辺には、'any' 型、'number' 型、または列挙型を指定してください。",
        "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": "単項算術演算のオペランドの型には、'any' 型、'number' 型、または列挙型を指定してください。",
        "Variable declarations of a 'for' statement cannot use a type annotation.": "'for' ステートメントの変数宣言で型の注釈を使用することはできません。",
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": "'for' ステートメントの変数宣言の型は 'string' または 'any' でなければなりません。",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "'for...in' ステートメントの右辺には、'any' 型、オブジェクト型、または型パラメーターを指定してください。",
        "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": "'in' 式の左辺の型は 'any'、'string'、または 'number' でなければなりません。",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": "'in' 式の右辺には、'any' 型、オブジェクト型、または型パラメーターを指定してください。",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "'instanceof' 式の左辺には、'any' 型、オブジェクト型、または型パラメーターを指定してください。",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "'instanceof' 式の右辺には、'any' 型、または 'Function' インターフェイス型に割り当てることができる型を指定してください。",
        "Setters cannot return a value.": "set アクセス操作子は値を返せません。",
        "Tried to query type of uninitialized module '{0}'.": "初期化されていないモジュール '{0}' の型をクエリしようとしました。",
        "Tried to set variable type to uninitialized module type '{0}'.": "変数の型を初期化されていないモジュール型 '{0}' に設定しようとしました。",
        "Type '{0}' does not have type parameters.": "型 '{0}' には型パラメーターはありません。",
        "Getters must return a value.": "get アクセス操作子は値を返す必要があります。",
        "Getter and setter accessors do not agree in visibility.": "get アクセサーおよび set アクセサーで表示が許可されていません。",
        "Invalid left-hand side of assignment expression.": "代入式の左辺が無効です。",
        "Function declared a non-void return type, but has no return expression.": "関数で void でない戻り値の型が宣言されていますが、return 式がありません。",
        "Cannot resolve return type reference.": "戻り値の型の参照を解決できません。",
        "Constructors cannot have a return type of 'void'.": "コンストラクターの戻り値の型を 'void' にすることはできません。",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "後続の変数宣言は同じ型でなければなりません。変数 '{0}' の型は '{1}' である必要がありますが、'{2}' になっています。",
        "All symbols within a with block will be resolved to 'any'.": "with ブロック内のシンボルはすべて 'any' に解決されます。",
        "Import declarations in an internal module cannot reference an external module.": "内部モジュール内のインポートの宣言で外部モジュールを参照することはできません。",
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": "クラス {0} でインターフェイス {1} が宣言されていますが、実装されていません: {NL}{2}",
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": "クラス {0} でクラス {1} がインターフェイスとして宣言されていますが、実装されていません: {NL}{2}",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "インクリメント演算子またはデクリメント演算子のオペランドには、変数、プロパティ、またはインデクサーを指定してください。",
        "'this' cannot be referenced in static initializers in a class body.": "'this' はクラス本体の静的初期化子では参照できません。",
        "Class '{0}' cannot extend class '{1}':{NL}{2}": "クラス '{0}' でクラス '{1}' を拡張できません: {NL}{2}",
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": "インターフェイス '{0}' でクラス '{1}' を拡張できません: {NL}{2}",
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": "インターフェイス '{0}' でインターフェイス '{1}' を拡張できません: {NL}{2}",
        "Duplicate overload signature for '{0}'.": "'{0}' のオーバーロードのシグネチャが重複しています。",
        "Duplicate constructor overload signature.": "コンストラクターのオーバーロードのシグネチャが重複しています。",
        "Duplicate overload call signature.": "オーバーロードの呼び出しシグネチャが重複しています。",
        "Duplicate overload construct signature.": "オーバーロードのコンストラクト シグネチャが重複しています。",
        "Overload signature is not compatible with function definition.": "オーバーロードのシグネチャを関数の定義と一緒に使用することはできません。",
        "Overload signature is not compatible with function definition:{NL}{0}": "オーバーロードのシグネチャを関数の定義と一緒に使用することはできません: {NL}{0}",
        "Overload signatures must all be public or private.": "オーバーロードのシグネチャは、すべてパブリックであるか、すべてプライベートであるかのどちらかである必要があります。",
        "Overload signatures must all be exported or not exported.": "オーバーロードのシグネチャは、すべてエクスポートされるか、すべてエクスポートされないかのどちらかである必要があります。",
        "Overload signatures must all be ambient or non-ambient.": "オーバーロードのシグネチャは、すべてアンビエントであるか、すべてアンビエントでないかのどちらかである必要があります。",
        "Overload signatures must all be optional or required.": "オーバーロードのシグネチャは、すべて省略可能であるか、すべて必須であるかのどちらかである必要があります。",
        "Specialized overload signature is not assignable to any non-specialized signature.": "特殊化されたオーバーロードのシグネチャは、特殊化されていないシグネチャに割り当てることはできません。",
        "'this' cannot be referenced in constructor arguments.": "'this' はコンストラクター引数では参照できません。",
        "Instance member cannot be accessed off a class.": "インスタンス メンバーにクラスからアクセスすることはできません。",
        "Untyped function calls may not accept type arguments.": "型指定のない関数の呼び出しで型引数を使用することはできません。",
        "Non-generic functions may not accept type arguments.": "ジェネリック以外の関数で型引数を使用することはできません。",
        "A generic type may not reference itself with a wrapped form of its own type parameters.": "ジェネリック型でそれ自体の型パラメーターをラップしてそれ自体を参照することはできません。",
        "Rest parameters must be array types.": "rest パラメーターは配列型でなければなりません。",
        "Overload signature implementation cannot use specialized type.": "オーバーロードのシグネチャの実装で特殊な型を使用することはできません。",
        "Export assignments may only be used at the top-level of external modules.": "エクスポートの割り当ては、最上位の外部モジュールでのみ使用できます。",
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": "エクスポートの割り当ては、変数、関数、クラス、インターフェイス、列挙、および内部モジュールでのみ実行できます。",
        "Only public methods of the base class are accessible via the 'super' keyword.": "基底クラスのパブリック メソッドのみが 'super' キーワードでアクセス可能です。",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.": "数値インデクサー型 '{0}' は、文字列インデクサー型 '{1}' に割り当てることができる型でなければなりません。",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}": "数値インデクサー型 '{0}' は、文字列インデクサー型 '{1}' に割り当てることができる型でなければなりません:{NL}{2}",
        "All numerically named properties must be assignable to numeric indexer type '{0}'.": "数値指定名前付きプロパティはすべて、数値インデクサー型 '{0}' に割り当てることができる型でなければなりません。",
        "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}": "数値指定名前付きプロパティはすべて、数値インデクサー型 '{0}' に割り当てることができる型でなければなりません:{NL}{1}",
        "All named properties must be assignable to string indexer type '{0}'.": "名前付きプロパティはすべて、文字列インデクサー型 '{0}' に割り当てることができる型でなければなりません。",
        "All named properties must be assignable to string indexer type '{0}':{NL}{1}": "名前付きプロパティはすべて、文字列インデクサー型 '{0}' に割り当てることができる型でなければなりません:{NL}{1}",
        "Generic type references must include all type arguments.": "ジェネリック型の参照にはすべての型引数を含める必要があります。",
        "Default arguments are only allowed in implementation.": "既定の引数は実装でのみ使用できます。",
        "Overloads cannot differ only by return type.": "戻り値の型のみが異なるオーバーロードは使用できません。",
        "Function expression declared a non-void return type, but has no return expression.": "関数式で void でない戻り値の型が宣言されていますが、return 式がありません。",
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": "内部モジュール内の識別子を参照するインポートの宣言は、変数、関数、クラス、インターフェイス、列挙、および内部モジュールでのみ実行できます。",
        "Could not find symbol '{0}' in module '{1}'.": "モジュール '{1}' 内のシンボル '{0}' が見つかりませんでした。",
        "Unable to resolve module reference '{0}'.": "モジュール参照 '{0}' を解決できません。",
        "Could not find module '{0}' in module '{1}'.": "モジュール '{1}' 内のモジュール '{0}' が見つかりませんでした。",
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": "エクスポートされたインポートの宣言 '{0}' に、プライベート型 '{1}' である (またはその型を使用している) 型を持つ値が割り当てられています。",
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": "エクスポートされたインポートの宣言 '{0}' に、アクセスできないモジュール '{1}' を使用している型を持つ値が割り当てられています。",
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": "エクスポートされたインポートの宣言 '{0}' に、プライベート型 '{1}' である (またはその型を使用している) 型が割り当てられています。",
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": "エクスポートされたインポートの宣言 '{0}' に、アクセスできないモジュール '{1}' を使用している型が割り当てられています。",
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": "エクスポートされたインポートの宣言 '{0}' に、アクセスできないモジュール '{1}' である (またはそのモジュールを使用している) コンテナーが割り当てられています。",
        "Type name '{0}' in extends clause does not reference constructor function for '{1}'.": "extends 句の型名 '{0}' が '{1}' のコンストラクター関数を参照していません。",
        "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": "インポートの宣言内の内部モジュール参照 '{0}' が '{1}' のモジュール インスタンスを参照していません。",
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": "モジュール '{0}' は異なるファイル '{2}' の '{1}' の以前の宣言とマージすることはできません。",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": "インターフェイス '{0}' は型 '{1}' と '{2}' を同時に拡張できません: {NL}{3}",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "パラメーター '{0}' の初期化子はその後で宣言された識別子 '{1}' を参照できません。",
        "Ambient external module declaration cannot be reopened.": "アンビエント外部モジュール宣言を再度開くことはできません。",
        "All declarations of merged declaration '{0}' must be exported or not exported.": "マージされた宣言 '{0}' のすべての宣言はエクスポートされるか、またはエクスポートされないかのどちらかである必要があります。",
        "'super' cannot be referenced in constructor arguments.": "'super' はコンストラクター引数では参照できません。",
        "Return type of constructor signature must be assignable to the instance type of the class.": "コンストラクター シグネチャの戻り値の型はクラスのインスタンス型に割り当て可能である必要があります。",
        "Ambient external module declaration must be defined in global context.": "アンビエント外部モジュール宣言はグローバル コンテキストで定義される必要があります。",
        "Ambient external module declaration cannot specify relative module name.": "アンビエント外部モジュール宣言では相対モジュール名を指定できません。",
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": "アンビエント外部モジュール宣言のインポートの宣言は相対外部モジュール名で外部モジュールを参照できません。",
        "Could not find the best common type of types of all return statement expressions.": "すべての return ステートメント式の型の最適な共通型が見つかりません。",
        "Import declaration cannot refer to external module reference when --noResolve option is set.": "--noResolve オプションが設定されている場合、インポート宣言は外部モジュール参照を参照できません。",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "識別子 '_this' が重複しています。コンパイラは変数宣言 '_this' を使用して '_this' の参照をキャプチャします。",
        "'continue' statement can only be used within an enclosing iteration statement.": "'continue' ステートメントは外側のイテレーション内でのみ使用できます。",
        "'break' statement can only be used within an enclosing iteration or switch statement.": "'break' ステートメントは外側のイテレーションまたは switch ステートメント内でのみ使用できます。",
        "Jump target not found.": "ジャンプ先が見つかりません。",
        "Jump target cannot cross function boundary.": "ジャンプ先は関数の境界を越えることはできません。",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "識別子 '_super' が重複しています。コンパイラは '_super' を使用して基底クラスの参照をキャプチャします。",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "コンパイラが 'this' の参照をキャプチャするために使用する変数宣言 '_this' に解決される式。",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "コンパイラが基底クラスの参照をキャプチャするために使用する '_super' に解決される式。",
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "エクスポートされたインターフェイスからのコンストラクター シグネチャの TypeParameter '{0}' はプライベート型 '{1}' です (またはその型を使用しています)。 ",
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "エクスポートされたインターフェイスからの呼び出しシグネチャの TypeParameter '{0}' はプライベート型 '{1}' です (またはその型を使用しています)。 ",
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": "エクスポートされたクラスからのパブリック静的メソッドの TypeParameter '{0}' はプライベート型 '{1}' です (またはその型を使用しています)。 ",
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": "エクスポートされたクラスからのパブリック メソッドの TypeParameter '{0}' はプライベート型 '{1}' です (またはその型を使用しています)。 ",
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": "エクスポートされたインターフェイスからメソッドの TypeParameter '{0}' はプライベート型 '{1}' です (またはその型を使用しています)。 ",
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": "エクスポートされた関数の TypeParameter '{0}' はプライベート型 '{1}' です (またはその型を使用しています)。 ",
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "エクスポートされたインターフェイスからのコンストラクター シグネチャの TypeParameter '{0}' はアクセスできないモジュール {1} を使用しています。",
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": "エクスポートされたインターフェイスからの呼び出しシグネチャの TypeParameter '{0}' はアクセスできないモジュール {1} を使用しています",
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": "エクスポートされたクラスからのパブリック静的メソッドの TypeParameter '{0}' はアクセスできないモジュール {1} を使用しています。",
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": "エクスポートされたクラスからのパブリック メソッドの TypeParameter '{0}' はアクセスできないモジュール {1} を使用しています。",
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": "エクスポートされたインターフェイスからのメソッドの TypeParameter '{0}' はアクセスできないモジュール {1} を使用しています。",
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": "エクスポートされた関数の TypeParameter '{0}' はアクセスできないモジュール {1} を使用しています。",
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": "エクスポートされたクラスの TypeParameter '{0}' はプライベート型 '{1}' です (またはその型を使用しています)。 ",
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": "エクスポートされたインターフェイスの TypeParameter '{0}' はプライベート型 '{1}' です (またはその型を使用しています)。 ",
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": "エクスポートされたクラスの TypeParameter '{0}' はアクセスできないモジュール {1} を使用しています。",
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": "エクスポートされたインターフェイスの TypeParameter '{0}' はアクセスできないモジュール {1} を使用しています。",
        "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": "識別子 '_i' が重複しています。コンパイラは '_i' を使用して rest パラメーターを初期化します。",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "識別子 'arguments' が重複しています。コンパイラは 'arguments' を使用して rest パラメーターを初期化します。",
        "Type of conditional '{0}' must be identical to '{1}' or '{2}'.": "条件付き '{0}' の型は '{1}' または '{2}' と同一でなければなりません。",
        "Type of conditional '{0}' must be identical to '{1}', '{2}' or '{3}'.": "条件付き '{0}' の型は '{1}'、'{2}'、または '{3}' と同一でなければなりません。",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": "識別子 '{0}' が重複しています。コンパイラは外部モジュールの最上位のスコープに名前 '{1}' を予約します。",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "型パラメーターの制約は同じ型パラメーター リストからすべての型パラメーターを参照できません。",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "インスタンス メンバー変数 '{0}' の初期化子はコンストラクターで宣言された識別子 '{1}' を参照できません。",
        "Parameter '{0}' cannot be referenced in its initializer.": "パラメーター '{0}' はその初期化子内では参照できません。",
        "Duplicate string index signature.": "string インデックス シグネチャが重複しています。",
        "Duplicate number index signature.": "number インデックス シグネチャが重複しています。",
        "All declarations of an interface must have identical type parameters.": "インターフェイスのすべての宣言に同一の型パラメーターが必要です。",
        "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.": "式は、コンパイラが rest パラメーターの初期化に使用する変数宣言 '_i' に解決されます。",
        "Type '{0}' is missing property '{1}' from type '{2}'.": "型 '{0}' に型 '{2}' のプロパティ '{1}' がありません。",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": "型 '{1}' と '{2}' のプロパティ '{0}' の型を同時に指定することはできません。",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": "型 '{1}' と '{2}' のプロパティ '{0}' の型を同時に指定することはできません: {NL}{3}",
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "型 '{1}' でプライベートとして定義されたプロパティ '{0}' が、型 '{2}' でパブリックとして定義されています。",
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "型 '{1}' でパブリックとして定義されたプロパティ '{0}' が、型 '{2}' でプライベートとして定義されています。",
        "Types '{0}' and '{1}' define property '{2}' as private.": "型 '{0}' および '{1}' でプロパティ '{2}' がプライベートとして定義されています。",
        "Call signatures of types '{0}' and '{1}' are incompatible.": "型 '{0}' と '{1}' の呼び出しシグネチャを同時に指定することはできません。",
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "型 '{0}' と '{1}' の呼び出しシグネチャを同時に指定することはできません: {NL}{2}",
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": "型 '{0}' に必要な呼び出しシグネチャが型 '{1}' にありません。",
        "Construct signatures of types '{0}' and '{1}' are incompatible.": "型 '{0}' と '{1}' のコンストラクト シグネチャを同時に指定することはできません。",
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "型 '{0}' と '{1}' のコンストラクト シグネチャを同時に指定することはできません: {NL}{2}",
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": "型 '{0}' に必要なコンストラクト シグネチャが型 '{1}' にありません。",
        "Index signatures of types '{0}' and '{1}' are incompatible.": "型 '{0}' と '{1}' のインデックス シグネチャを同時に指定することはできません。",
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "型 '{0}' と '{1}' のインデックス シグネチャを同時に指定することはできません: {NL}{2}",
        "Call signature expects {0} or fewer parameters.": "呼び出しシグネチャのパラメーターは {0} 個以下にする必要があります。",
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": "型が '{2}' の引数 {1} に型 '{0}' を適用できません。",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "クラス '{0}' で定義されたインスタンス メンバー アクセサー '{1}' が、拡張されたクラス '{2}' ではインスタンス メンバー関数として定義されています。",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "クラス '{0}' で定義されたインスタンス メンバー プロパティ '{1}' が、拡張されたクラス '{2}' ではインスタンス メンバー関数として定義されています。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "クラス '{0}' で定義されたインスタンス メンバー関数 '{1}' が、拡張されたクラス '{2}' ではインスタンス メンバー アクセサーとして定義されています。",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "クラス '{0}' で定義されたインスタンス メンバー関数 '{1}' が、拡張されたクラス '{2}' ではインスタンス メンバー プロパティとして定義されています。",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": "クラス '{1}' とクラス '{2}' の静的プロパティ '{0}' の型を同時に指定することはできません。",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": "クラス '{1}' とクラス '{2}' の静的プロパティ '{0}' の型を同時に指定することはできません: {NL}{3}",
        "Type reference cannot refer to container '{0}'.": "型参照でコンテナー '{0}' を参照できません。",
        "Type reference must refer to type.": "型参照で型を参照する必要があります。",
        "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.": "複数の宣言がある列挙で、最初の列挙要素の初期化子を省略できるのは 1 つの宣言のみです。",
        " (+ {0} overload(s))": " (+ {0} オーバーロード)",
        "Variable declaration cannot have the same name as an import declaration.": "変数宣言はインポートの宣言と同じ名前を指定することはできません。",
        "Signature expected {0} type arguments, got {1} instead.": "シグネチャは {0} 型の引数を想定しましたが、{1} を受け取りました。",
        "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": "プロパティ '{0}' は型 '{1}' で省略可能として定義されていますが、型 '{2}' で必要です。",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.": "無限に展開する型参照から生成された型 '{0}' および '{1}' は同じ名前の型を参照しません。",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.": "無限に展開する型参照から生成された型 '{0}' および '{1}' には互換性のない型引数があります。",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}": "無限に展開する型参照から生成された型 '{0}' および '{1}' には互換性のない型引数があります: {NL}{2}",
        "Named properties '{0}' of types '{1}' and '{2}' are not identical.": "型 '{1}' および '{2}' の名前付きプロパティ '{0}' は同一ではありません。",
        "Types of string indexer of types '{0}' and '{1}' are not identical.": "型 '{0}' および '{1}' の文字列インデクサーの型は同一ではありません。",
        "Types of number indexer of types '{0}' and '{1}' are not identical.": "型 '{0}' および '{1}' の数値インデクサーの型は同一ではありません。",
        "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}": "型 '{0}' の数値インデクサーの型は、型 '{1}' の文字列インデクサー型に割り当てることはできません。{NL}{2}",
        "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}": "型 '{1}' のプロパティ '{0}' の型は、型 '{2}' の文字列インデクサー型に割り当てることはできません。{NL}{3}",
        "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}": "型 '{1}' のプロパティ '{0}' の型は、型 '{2}' の数値インデクサー型に割り当てることはできません。{NL}{3}",
        "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "型 '{1}' でプライベートとして定義された静的プロパティ '{0}' が、型 '{2}' でパブリックとして定義されています。",
        "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "型 '{1}' でパブリックとして定義された静的プロパティ '{0}' が、型 '{2}' でプライベートとして定義されています。",
        "Types '{0}' and '{1}' define static property '{2}' as private.": "型 '{0}' および '{1}' で静的プロパティ '{2}' がプライベートとして定義されています。",
        "Current host does not support '{0}' option.": "現在のホストでは '{0}' オプションはサポートされていません。",
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": "ECMAScript ターゲット バージョン '{0}' はサポートされていません。有効なターゲット バージョンを指定してください: '{1}' (既定)、または '{2}'",
        "Module code generation '{0}' not supported.": "モジュール コード生成 '{0}' はサポートされていません。",
        "Could not find file: '{0}'.": "ファイルが見つかりません: '{0}'。",
        "A file cannot have a reference to itself.": "ファイルにそれ自体への参照を含めることはできません。",
        "Cannot resolve referenced file: '{0}'.": "参照ファイルを解決できません: '{0}'。",
        "Cannot find the common subdirectory path for the input files.": "入力ファイルの共通サブディレクトリ パスが見つかりません。",
        "Emit Error: {0}.": "生成エラー: {0}。",
        "Cannot read file '{0}': {1}": "ファイル '{0}' を読み取れません: {1}",
        "Unsupported file encoding.": "サポートされていないファイルのエンコードです。",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "ロケールは <language> または <language>-<territory> の形式で指定する必要があります。例: '{0}' または '{1}'。",
        "Unsupported locale: '{0}'.": "サポートされていないロケールです: '{0}'。",
        "Execution Failed.{NL}": "実行に失敗しました。{NL}",
        "Invalid call to 'up'": "'up' の呼び出しが無効です",
        "Invalid call to 'down'": "'down' の呼び出しが無効です",
        "Base64 value '{0}' finished with a continuation bit.": "Base64 値 '{0}' が継続ビットで終了しています。",
        "Unknown option '{0}'": "不明なオプション '{0}'",
        "Expected {0} arguments to message, got {1} instead.": "メッセージの想定される引数の数は {0} 個ですが、{1} 個受け取りました。",
        "Expected the message '{0}' to have {1} arguments, but it had {2}": "メッセージ '{0}' の想定される引数の数は {1} 個ですが、{2} 個含まれています",
        "Could not delete file '{0}'": " ファイル '{0}' を削除できませんでした",
        "Could not create directory '{0}'": "ディレクトリ '{0}' を作成できませんでした",
        "Error while executing file '{0}': ": "ファイル '{0}' の実行中にエラーが発生しました: ",
        "Cannot compile external modules unless the '--module' flag is provided.": "'--module' フラグが指定されていないと外部モジュールをコンパイルできません。",
        "Option mapRoot cannot be specified without specifying sourcemap option.": "sourcemap オプションを指定せずに mapRoot オプションを指定することはできません。",
        "Option sourceRoot cannot be specified without specifying sourcemap option.": "sourcemap オプションを指定せずに sourceRoot オプションを指定することはできません。",
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": "sourcemap オプションを指定せずに mapRoot および sourceRoot オプションを指定することはできません。",
        "Option '{0}' specified without '{1}'": "オプション '{0}' が指定されましたが、'{1}' がありません。",
        "'codepage' option not supported on current platform.": "現在のプラットフォームでは 'codepage' オプションはサポートされていません。",
        "Concatenate and emit output to single file.": "出力を連結して 1 つのファイルを生成する。",
        "Generates corresponding {0} file.": "対応する {0} ファイルを生成します。",
        "Specifies the location where debugger should locate map files instead of generated locations.": "生成された場所ではなくデバッガーがマップ ファイルを探す必要がある場所を指定します。",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "ソースの場所ではなくデバッガーが TypeScript ファイルを探す必要がある場所を指定します。",
        "Watch input files.": "ウォッチの入力ファイル。",
        "Redirect output structure to the directory.": "ディレクトリへ出力構造をリダイレクトします。",
        "Do not emit comments to output.": "コメントを出力しません。",
        "Skip resolution and preprocessing.": "解決と前処理をスキップします。",
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": "ECMAScript ターゲット バージョンを指定します: '{0}' (既定)、または '{1}'",
        "Specify module code generation: '{0}' or '{1}'": "モジュール コード生成を指定します: '{0}' または '{1}'",
        "Print this message.": "このメッセージを印刷します。",
        "Print the compiler's version: {0}": "コンパイラのバージョンの印刷: {0}",
        "Allow use of deprecated '{0}' keyword when referencing an external module.": "外部モジュールの参照時に非推奨の '{0}' キーワードの使用を許可します。",
        "Specify locale for errors and messages. For example '{0}' or '{1}'": "エラーとメッセージのロケールを指定します。例: '{0}' または '{1}'",
        "Syntax:   {0}": "構文: {0}",
        "options": "オプション",
        "file1": "ファイル",
        "Examples:": "例:",
        "Options:": "オプション:",
        "Insert command line options and files from a file.": "コマンド ライン オプションとファイルをファイルから挿入します。",
        "Version {0}": "バージョン {0}",
        "Use the '{0}' flag to see options.": "'{0}' フラグを使用してオプションを表示します。",
        "{NL}Recompiling ({0}):": "{NL}再コンパイル ({0}):",
        "STRING": "文字列",
        "KIND": "種類",
        "file2": "ファイル",
        "VERSION": "バージョン",
        "LOCATION": "位置",
        "DIRECTORY": "ディレクトリ",
        "NUMBER": "番号",
        "Specify the codepage to use when opening source files.": "ソース ファイルを開くときに使用するコードページを指定します。",
        "Additional locations:": "追加の場所:",
        "This version of the Javascript runtime does not support the '{0}' function.": "このバージョンの Javascript ランタイムでは '{0}' 関数はサポートされていません。",
        "Unknown rule.": "不明なルールです。",
        "Invalid line number ({0})": "行番号 ({0}) が無効です",
        "Warn on expressions and declarations with an implied 'any' type.": "暗黙的な 'any' 型を持つ式と宣言に対する警告。",
        "Variable '{0}' implicitly has an 'any' type.": "変数 '{0}' は暗黙的に 'any' 型になります。",
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": "'{1}' のパラメーター '{0}' は暗黙的に 'any' 型になります。",
        "Parameter '{0}' of function type implicitly has an 'any' type.": "関数型のパラメーター '{0}' は暗黙的に 'any' 型になります。",
        "Member '{0}' of object type implicitly has an 'any' type.": "オブジェクト型のメンバー '{0}' は暗黙的に 'any' 型になります。",
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": "コンストラクター シグネチャがない \"new\" 式は、暗黙的に 'any' 型になります。",
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": "'{0}' は、戻り値の型の注釈がないため、暗黙的に戻り値の型 'any' になります。",
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": "関数式は、戻り値の型の注釈がないため、暗黙的に戻り値の型 'any' になります。",
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": "lambda 関数のパラメーター '{0}' は暗黙的に 'any' 型になります。",
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": "コンストラクター シグネチャは、戻り値の型の注釈がないため、暗黙的に戻り値の型 'any' になります。",
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": "lambda 関数は、戻り値の型の注釈がないため、暗黙的に戻り値の型 'any' になります。",
        "Array Literal implicitly has an 'any' type from widening.": "配列リテラルは拡張によって暗黙的に 'any' 型になります。",
        "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": "'get' アクセサーおよび 'set' アクセサーのパラメーター型の注釈がない '{0}' は、暗黙的に 'any' 型になります。",
        "Index signature of object type implicitly has an 'any' type.": "オブジェクト型のインデックス シグネチャは暗黙的に 'any' 型になります。",
        "Object literal's property '{0}' implicitly has an 'any' type from widening.": "オブジェクト リテラルのプロパティ '{0}' は拡張によって暗黙的に 'any' 型になります。"
}