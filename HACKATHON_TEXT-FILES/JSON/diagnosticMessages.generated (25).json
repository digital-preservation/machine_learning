{
        "error TS{0}: {1}": "TS erreur {0} : {1}",
        "warning TS{0}: {1}": "TS avertissement {0} : {1}",
        "Unrecognized escape sequence.": "Séquence d'échappement non reconnue.",
        "Unexpected character {0}.": "Caractère inattendu {0}.",
        "Missing close quote character.": "Guillemet fermant manquant.",
        "Identifier expected.": "Identificateur attendu.",
        "'{0}' keyword expected.": "Mot clé '{0}' attendu.",
        "'{0}' expected.": "'{0}' attendu.",
        "Identifier expected; '{0}' is a keyword.": "Identificateur attendu ; '{0}' est un mot clé.",
        "Automatic semicolon insertion not allowed.": "L'insertion automatique de points-virgules n'est pas autorisée.",
        "Unexpected token; '{0}' expected.": "Jeton inattendu ; '{0}' attendu.",
        "Trailing separator not allowed.": "Séparateur de fin non autorisé.",
        "'*/' expected.": "'*/' attendu.",
        "'public' or 'private' modifier must precede 'static'.": "Le modificateur 'public' ou 'private' doit précéder 'static'.",
        "Unexpected token.": "Jeton inattendu.",
        "Catch clause parameter cannot have a type annotation.": "Une paramètre de clause catch ne peut pas avoir une annotation de type.",
        "Rest parameter must be last in list.": "Le paramètre rest doit être le dernier de la liste.",
        "Parameter cannot have question mark and initializer.": "Un paramètre ne peut pas contenir de point d'interrogation et d'initialiseur.",
        "Required parameter cannot follow optional parameter.": "Un paramètre requis ne peut pas suivre un paramètre facultatif.",
        "Index signatures cannot have rest parameters.": "Les signatures d'index ne peuvent pas avoir de paramètres rest.",
        "Index signature parameter cannot have accessibility modifiers.": "Le paramètre de signature d'index ne peut pas avoir de modificateurs d'accessibilité.",
        "Index signature parameter cannot have a question mark.": "Le paramètre de signature d'index ne peut pas contenir de point d'interrogation.",
        "Index signature parameter cannot have an initializer.": "Le paramètre de signature d'index ne peut pas avoir d'initialiseur.",
        "Index signature must have a type annotation.": "La signature d'index doit avoir une annotation de type.",
        "Index signature parameter must have a type annotation.": "Le paramètre de signature d'index doit avoir une annotation de type.",
        "Index signature parameter type must be 'string' or 'number'.": "Le type du paramètre de signature d'index doit être 'string' ou 'number'.",
        "'extends' clause already seen.": "Clause 'extends' déjà rencontrée.",
        "'extends' clause must precede 'implements' clause.": "La clause 'extends' doit précéder la clause 'implements'.",
        "Classes can only extend a single class.": "Les classes peuvent seulement étendre une classe unique.",
        "'implements' clause already seen.": "Clause 'implements' déjà rencontrée.",
        "Accessibility modifier already seen.": "Modificateur d'accessibilité déjà rencontré.",
        "'{0}' modifier must precede '{1}' modifier.": "Le modificateur '{0}' doit précéder le modificateur '{1}'.",
        "'{0}' modifier already seen.": "Modificateur '{0}' déjà rencontré.",
        "'{0}' modifier cannot appear on a class element.": "Le modificateur '{0}' ne peut pas apparaître dans un élément de classe.",
        "Interface declaration cannot have 'implements' clause.": "Une déclaration Interface ne peut pas avoir de clause 'implements'.",
        "'super' invocation cannot have type arguments.": "L'appel de 'super' ne peut pas avoir d'arguments de type.",
        "Only ambient modules can use quoted names.": "Seuls les modules ambiants peuvent utiliser de noms entre guillemets.",
        "Statements are not allowed in ambient contexts.": "Les instructions ne sont pas autorisées dans les contextes ambiants.",
        "Implementations are not allowed in ambient contexts.": "Les implémentations ne sont pas autorisées dans les contextes ambiants.",
        "'declare' modifier not allowed for code already in an ambient context.": "Le modificateur 'declare' n'est pas autorisé pour du code qui figure déjà dans un contexte ambiant.",
        "Initializers are not allowed in ambient contexts.": "Les initialiseurs ne sont pas autorisés dans les contextes ambiants.",
        "Parameter property declarations can only be used in a non-ambient constructor declaration.": "Les déclarations de propriétés de paramètres peuvent être utilisées uniquement dans une déclaration de constructeur non ambiante.",
        "Function implementation expected.": "Implémentation de fonction attendue.",
        "Constructor implementation expected.": "Implémentation de constructeur attendue.",
        "Function overload name must be '{0}'.": "Le nom de la surcharge de fonction doit être '{0}'.",
        "'{0}' modifier cannot appear on a module element.": "Le modificateur '{0}' ne peut pas apparaître dans un élément de module.",
        "'declare' modifier cannot appear on an interface declaration.": "Le modificateur 'declare' ne peut pas apparaître dans une déclaration d'interface.",
        "'declare' modifier required for top level element.": "Modificateur 'declare' requis pour l'élément de niveau supérieur.",
        "Rest parameter cannot be optional.": "Le paramètre rest ne peut pas être facultatif.",
        "Rest parameter cannot have an initializer.": "Le paramètre rest ne peut pas avoir d'initialiseur.",
        "'set' accessor must have one and only one parameter.": "Un accesseur 'set' ne peut avoir qu'un seul et unique paramètre.",
        "'set' accessor parameter cannot be optional.": "Le paramètre d'accesseur 'set' ne peut pas être facultatif.",
        "'set' accessor parameter cannot have an initializer.": "Un paramètre d'accesseur 'set' ne peut pas avoir d'initialiseur.",
        "'set' accessor cannot have rest parameter.": "Un accesseur 'set' ne peut pas avoir de paramètre rest.",
        "'get' accessor cannot have parameters.": "Un accesseur 'get' ne peut pas avoir de paramètres.",
        "Modifiers cannot appear here.": "Les modificateurs ne peuvent pas apparaître ici.",
        "Accessors are only available when targeting ECMAScript 5 and higher.": "Les accesseurs sont disponibles uniquement lors du ciblage de EcmaScript 5 et ultérieures.",
        "Class name cannot be '{0}'.": "Le nom de la classe ne peut pas être '{0}'.",
        "Interface name cannot be '{0}'.": "Le nom de l'interface ne peut pas être '{0}'.",
        "Enum name cannot be '{0}'.": "Le nom d'enum ne peut pas être '{0}'.",
        "Module name cannot be '{0}'.": "Le nom d'un module ne peut pas être '{0}'.",
        "Enum member must have initializer.": "Un membre enum doit posséder un initialiseur.",
        "Export assignment cannot be used in internal modules.": "Impossible d'utiliser une assignation d'exportation dans des modules internes.",
        "Export assignment not allowed in module with exported element.": "L'assignation d'exportation n'est pas autorisée dans un module comportant un élément exporté.",
        "Module cannot have multiple export assignments.": "Un module ne peut pas avoir plusieurs assignations d'exportation.",
        "Ambient enum elements can only have integer literal initializers.": "Les éléments d'enum ambiants peuvent uniquement avoir des initialiseurs de littéral d'entier.",
        "module, class, interface, enum, import or statement": "module, classe, interface, enum, importation ou instruction",
        "constructor, function, accessor or variable": "constructeur, fonction, accesseur ou variable",
        "statement": "instruction",
        "case or default clause": "cas ou clause par défaut",
        "identifier": "identificateur",
        "call, construct, index, property or function signature": "appel, construction, index, propriété ou signature de fonction",
        "expression": "expression",
        "type name": "nom de type",
        "property or accessor": "propriété ou accesseur",
        "parameter": "paramètre",
        "type": "type",
        "type parameter": "paramètre de type",
        "'declare' modifier not allowed on import declaration.": "Modificateur 'declare' non autorisé sur la déclaration Import.",
        "Function overload must be static.": "La surcharge de fonction doit être statique.",
        "Function overload must not be static.": "La surcharge de fonction ne doit pas être statique.",
        "Parameter property declarations cannot be used in a constructor overload.": "Les déclarations de propriété de paramètre ne peuvent pas être utilisées dans une surcharge de constructeur.",
        "Invalid 'reference' directive syntax.": "Syntaxe de directive 'reference' non valide.",
        "Octal literals are not available when targeting ECMAScript 5 and higher.": "Les littéraux octaux ne sont pas disponibles lors du ciblage d'ECMAScript 5 et versions ultérieures.",
        "Accessors are not allowed in ambient contexts.": "Les accesseurs ne sont pas autorisés dans les contextes ambiants.",
        "'{0}' modifier cannot appear on a constructor declaration.": "Le modificateur '{0}' ne peut pas apparaître sur une déclaration de constructeur.",
        "'{0}' modifier cannot appear on a parameter.": "Le modificateur '{0}' ne peut pas apparaître sur un paramètre.",
        "Only a single variable declaration is allowed in a 'for...in' statement.": "Une seule déclaration de variable est autorisée dans une instruction 'for...in'.",
        "Type parameters cannot appear on a constructor declaration.": "Les paramètres de type ne peuvent pas apparaître sur une déclaration de constructeur.",
        "Type annotation cannot appear on a constructor declaration.": "Une annotation de type ne peut pas apparaître sur une déclaration de constructeur.",
        "Duplicate identifier '{0}'.": "Dupliquer le modificateur '{0}'.",
        "The name '{0}' does not exist in the current scope.": "Le nom '{0}' n'existe pas dans la portée actuelle.",
        "The name '{0}' does not refer to a value.": "Le nom '{0}' ne fait pas référence à une valeur.",
        "'super' can only be used inside a class instance method.": "'super' peut seulement être utilisé dans une méthode d'instance de classe.",
        "The left-hand side of an assignment expression must be a variable, property or indexer.": "La partie gauche d'une expression d'assignation doit être une variable, une propriété ou un indexeur.",
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": "La valeur de type '{0}' ne peut pas être appelée. Voulez-vous inclure 'new' ?",
        "Value of type '{0}' is not callable.": "La valeur de type '{0}' ne peut pas être appelée.",
        "Value of type '{0}' is not newable.": "La valeur de type '{0}' ne peut pas être renouvelée.",
        "Value of type '{0}' is not indexable by type '{1}'.": "La valeur de type '{0}' n'est pas indexable par le type '{1}'.",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": "L'opérateur '{0}' ne peut pas être appliqué aux types '{1}' et '{2}'.",
        "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": "L'opérateur '{0}' ne peut pas être appliqué aux types '{1}' et '{2}' : {3}",
        "Cannot convert '{0}' to '{1}'.": "Impossible de convertir '{0}' en '{1}'.",
        "Cannot convert '{0}' to '{1}':{NL}{2}": "Impossible de convertir '{0}' en '{1}' :{NL}{2}",
        "Expected var, class, interface, or module.": "var, classe, interface ou module attendu.",
        "Operator '{0}' cannot be applied to type '{1}'.": "L'opérateur '{0}' ne peut pas être appliqué au type '{1}'.",
        "Getter '{0}' already declared.": "Accesseur Get '{0}' déjà déclaré.",
        "Setter '{0}' already declared.": "Méthode setter '{0}' déjà déclarée.",
        "Exported class '{0}' extends private class '{1}'.": "La classe exportée '{0}' étend la classe privée '{1}'.",
        "Exported class '{0}' implements private interface '{1}'.": "La classe exportée '{0}' implémente l'interface privée '{1}'.",
        "Exported interface '{0}' extends private interface '{1}'.": "L'interface exportée '{0}' étend l'interface privée '{1}'.",
        "Exported class '{0}' extends class from inaccessible module {1}.": "La classe exportée '{0}' étend la classe à partir du module inaccessible {1}.",
        "Exported class '{0}' implements interface from inaccessible module {1}.": "La classe exportée '{0}' implémente l'interface à partir du module inaccessible {1}.",
        "Exported interface '{0}' extends interface from inaccessible module {1}.": "L'interface exportée '{0}' étend l'interface à partir du module inaccessible {1}.",
        "Public static property '{0}' of exported class has or is using private type '{1}'.": "La propriété statique publique '{0}' de la classe exportée possède ou utilise un type privé '{1}'.",
        "Public property '{0}' of exported class has or is using private type '{1}'.": "La propriété publique '{0}' de la classe exportée possède ou utilise un type privé '{1}'.",
        "Property '{0}' of exported interface has or is using private type '{1}'.": "La propriété '{0}' de l'interface exportée possède ou utilise un type privé '{1}'.",
        "Exported variable '{0}' has or is using private type '{1}'.": "La variable exportée '{0}' possède ou utilise un type privé '{1}'.",
        "Public static property '{0}' of exported class is using inaccessible module {1}.": "La propriété statique publique '{0}' de la classe exportée utilise un module inaccessible {1}.",
        "Public property '{0}' of exported class is using inaccessible module {1}.": "La propriété publique '{0}' de la classe exportée utilise un module inaccessible {1}.",
        "Property '{0}' of exported interface is using inaccessible module {1}.": "La propriété '{0}' de l'interface exportée utilise un module inaccessible {1}.",
        "Exported variable '{0}' is using inaccessible module {1}.": "La variable exportée '{0}' utilise un module inaccessible {1}.",
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": "Le paramètre '{0}' du constructeur à partir de la classe exportée possède ou utilise un type privé '{1}'.",
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": "Le paramètre '{0}' de la méthode setter d'une propriété statique publique à partir de la classe exportée possède ou utilise un type privé '{1}'.",
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": "Le paramètre '{0}' de la méthode setter d'une propriété publique à partir de la classe exportée possède ou utilise un type privé '{1}'.",
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "Le paramètre '{0}' de la signature du constructeur à partir de l'interface exportée possède ou utilise un type privé '{1}'.",
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "Le paramètre '{0}' de la signature d'appel à partir de l'interface exportée possède ou utilise un type privé '{1}'.",
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": "Le paramètre '{0}' de la méthode statique publique à partir de la classe exportée possède ou utilise un type privé '{1}'.",
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": "Le paramètre '{0}' de la méthode publique à partir de la classe exportée possède ou utilise un type privé '{1}'.",
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": "Le paramètre '{0}' de la méthode à partir de l'interface exportée possède ou utilise un type privé '{1}'.",
        "Parameter '{0}' of exported function has or is using private type '{1}'.": "Le paramètre '{0}' de la fonction exportée possède ou utilise un type privé '{1}'.",
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": "Le paramètre '{0}' du constructeur à partir de la classe exportée utilise un module inaccessible {1}.",
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": "Le paramètre '{0}' de la méthode setter d'une propriété statique publique à partir de la classe exportée utilise un module inaccessible {1}.",
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": "Le paramètre '{0}' de la méthode setter d'une propriété publique à partir de la classe exportée utilise un module inaccessible {1}.",
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "Le paramètre '{0}' de la signature du constructeur à partir de l'interface exportée utilise un module inaccessible {1}.",
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": "Le paramètre '{0}' de la signature d'appel à partir de l'interface exportée utilise un module inaccessible {1}",
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": "Le paramètre '{0}' de la méthode statique publique à partir de la classe exportée utilise un module inaccessible {1}.",
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": "Le paramètre '{0}' de la méthode publique à partir de la classe exportée utilise un module inaccessible {1}.",
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": "Le paramètre '{0}' de la méthode à partir de l'interface exportée utilise un module inaccessible {1}.",
        "Parameter '{0}' of exported function is using inaccessible module {1}.": "Le paramètre '{0}' de la fonction exportée utilise un module inaccessible {1}.",
        "Return type of public static property getter from exported class has or is using private type '{0}'.": "Le type de retour de l'accesseur Get d'une propriété statique publique à partir de la classe exportée possède ou utilise un type privé '{0}'.",
        "Return type of public property getter from exported class has or is using private type '{0}'.": "Le type de retour de l'accesseur Get de propriété publique à partir de la classe exportée possède ou utilise un type privé '{0}'.",
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": "Le type de retour de la signature du constructeur à partir de l'interface exportée possède ou utilise un type privé '{0}'.",
        "Return type of call signature from exported interface has or is using private type '{0}'.": "Le type de retour de la signature d'appel à partir de l'interface exportée possède ou utilise un type privé '{0}'.",
        "Return type of index signature from exported interface has or is using private type '{0}'.": "Le type de retour de la signature d'index à partir de l'interface exportée possède ou utilise un type privé '{0}'.",
        "Return type of public static method from exported class has or is using private type '{0}'.": "Le type de retour de la méthode statique publique à partir de la classe exportée possède ou utilise un type privé '{0}'.",
        "Return type of public method from exported class has or is using private type '{0}'.": "Le type de retour de la méthode publique à partir de la classe exportée possède ou utilise un type privé '{0}'.",
        "Return type of method from exported interface has or is using private type '{0}'.": "Le type de retour de la méthode à partir de l'interface exportée possède ou utilise un type privé '{0}'.",
        "Return type of exported function has or is using private type '{0}'.": "Le type de retour de la fonction exportée possède ou utilise un type privé '{0}'.",
        "Return type of public static property getter from exported class is using inaccessible module {0}.": "Le type de retour de l'accesseur Get d'une propriété statique publique à partir de la classe exportée utilise un module inaccessible {0}.",
        "Return type of public property getter from exported class is using inaccessible module {0}.": "Le type de retour de l'accesseur Get de propriété publique à partir de la classe exportée utilise un module inaccessible {0}.",
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": "Le type de retour de la signature du constructeur à partir de l'interface exportée utilise un module inaccessible {0}.",
        "Return type of call signature from exported interface is using inaccessible module {0}.": "Le type de retour de la signature d'appel à partir de l'interface exportée utilise un module inaccessible {0}.",
        "Return type of index signature from exported interface is using inaccessible module {0}.": "Le type de retour de la signature d'index à partir de l'interface exportée utilise un module inaccessible {0}.",
        "Return type of public static method from exported class is using inaccessible module {0}.": "Le type de retour de la méthode statique publique à partir de la classe exportée utilise un module inaccessible {0}.",
        "Return type of public method from exported class is using inaccessible module {0}.": "Le type de retour de la méthode publique à partir de la classe exportée utilise un module inaccessible {0}.",
        "Return type of method from exported interface is using inaccessible module {0}.": "Le type de retour de la méthode à partir de l'interface exportée utilise un module inaccessible {0}.",
        "Return type of exported function is using inaccessible module {0}.": "Le type de retour de la fonction exportée utilise un module inaccessible {0}.",
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": "'new T[]' ne peut pas être utilisé pour créer un tableau. Utilisez 'new Array<T>()' à la place.",
        "A parameter list must follow a generic type argument list. '(' expected.": "Une liste d'arguments doit suivre une liste d'arguments de type générique. '(' attendue.",
        "Multiple constructor implementations are not allowed.": "Les implémentations de plusieurs constructeurs ne sont pas autorisées.",
        "Unable to resolve external module '{0}'.": "Impossible de résoudre le module externe '{0}'.",
        "Module cannot be aliased to a non-module type.": "Un type non-module ne peut pas être l'alias d'un module.",
        "A class may only extend another class.": "Une classe peut uniquement étendre une autre classe.",
        "A class may only implement another class or interface.": "Une classe peut uniquement implémenter une autre classe ou interface.",
        "An interface may only extend another class or interface.": "Une interface peut uniquement étendre une autre classe ou interface.",
        "Unable to resolve type.": "Impossible de résoudre le type.",
        "Unable to resolve type of '{0}'.": "Impossible de résoudre le type de '{0}'.",
        "Unable to resolve type parameter constraint.": "Impossible de résoudre la contrainte de paramètre de type.",
        "Type parameter constraint cannot be a primitive type.": "La contrainte de paramètre de type ne peut pas être un type primitif.",
        "Supplied parameters do not match any signature of call target.": "Les paramètres fournis ne correspondent à aucune signature de la cible de l'appel.",
        "Supplied parameters do not match any signature of call target:{NL}{0}": "Les paramètres fournis ne correspondent à aucune signature de la cible de l'appel :{NL}{0}",
        "Invalid 'new' expression.": "Expression 'new' non valide.",
        "Call signatures used in a 'new' expression must have a 'void' return type.": "Les signatures d'appel utilisées dans une expression 'new' doivent avoir un type de retour 'void'.",
        "Could not select overload for 'new' expression.": "Impossible de sélectionner la surcharge pour l'expression 'new'.",
        "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": "Le type '{0}' ne satisfait pas la contrainte '{1}' pour le paramètre de type '{2}'.",
        "Could not select overload for 'call' expression.": "Impossible de sélectionner la surcharge pour l'expression 'call'.",
        "Cannot invoke an expression whose type lacks a call signature.": "Impossible d'appeler une expression dont le type ne possède pas de signature d'appel.",
        "Calls to 'super' are only valid inside a class.": "Les appels à 'super' sont uniquement valides dans une classe.",
        "Generic type '{0}' requires {1} type argument(s).": "Le type générique '{0}' requiert {1} arguments de type.",
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": "Impossible de déterminer le type du littéral de tableau. Impossible de trouver le meilleur type commun pour les éléments de tableau.",
        "Could not find enclosing symbol for dotted name '{0}'.": "Impossible de trouver le symbole englobant pour le nom séparé par des points '{0}'.",
        "The property '{0}' does not exist on value of type '{1}'.": "La propriété '{0}' n'existe pas sur une valeur de type '{1}'.",
        "Could not find symbol '{0}'.": "Symbole '{0}' introuvable.",
        "'get' and 'set' accessor must have the same type.": "Les accesseurs 'get' et 'set' doivent avoir le même type.",
        "'this' cannot be referenced in current location.": "'this' ne peut pas être référencé dans l'emplacement actuel.",
        "Static members cannot reference class type parameters.": "Les membres statiques ne peuvent pas faire référence à des paramètres de type de classe.",
        "Class '{0}' is recursively referenced as a base type of itself.": "La classe '{0}' est référencée de manière récursive comme type de base d'elle-même.",
        "Interface '{0}' is recursively referenced as a base type of itself.": "L'interface '{0}' est référencée de manière récursive comme type de base d'elle-même.",
        "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.": "L'accès aux propriétés 'super' est autorisé uniquement dans un constructeur, une fonction membre ou un accesseur membre d'une classe dérivée.",
        "'super' cannot be referenced in non-derived classes.": "'super' ne peut pas être référencé dans les classes non dérivées.",
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": "Un appel de 'super' doit être la première instruction du constructeur lorsqu'une classe contient des propriétés initialisées ou possède des propriétés de paramètre.",
        "Constructors for derived classes must contain a 'super' call.": "Les constructeurs pour les classes dérivées doivent contenir un appel de 'super'.",
        "Super calls are not permitted outside constructors or in nested functions inside constructors.": "Les appels à 'super' ne sont pas autorisés hors des constructeurs ou dans des fonctions imbriquées dans des constructeurs.",
        "'{0}.{1}' is inaccessible.": "'{0}.{1}' est inaccessible.",
        "'this' cannot be referenced within module bodies.": "'this' ne peut pas être référencé dans les corps de module.",
        "Invalid '+' expression - types not known to support the addition operator.": "Expression '+' non valide - types inconnus pour la prise en charge de l'opérateur d'addition.",
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "La partie droite d'une opération arithmétique doit être de type 'any', 'number' ou un type enum.",
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": "La partie gauche d'une opération arithmétique doit être de type 'any', 'number' ou un type enum.",
        "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": "Le type d'opérande d'une opération arithmétique unaire doit être de type 'any', 'number' ou un type enum.",
        "Variable declarations of a 'for' statement cannot use a type annotation.": "Les déclarations de variable d'une instruction 'for' ne peuvent pas utiliser d'annotation de type.",
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": "Les déclarations de variable d'une instruction 'for' doivent être des types 'string' ou 'any'.",
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": "La partie droite d'une instruction 'for...in' doit être de type 'any', un type d'objet ou un paramètre de type.",
        "The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.": "Le côté gauche d'une expression 'in' doit être de type 'any', 'string' ou 'number'.",
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": "La partie droite d'une expression 'in' doit être de type 'any', un type d'objet ou un paramètre de type.",
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": "La partie gauche d'une expression 'instanceof' doit être de type 'any', un type d'objet ou un paramètre de type.",
        "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.": "La partie droite d'une expression 'instanceof' doit être de type 'any' ou d'un type assignable au type d'interface 'Function'.",
        "Setters cannot return a value.": "Les méthodes setter ne peuvent pas retourner une valeur.",
        "Tried to query type of uninitialized module '{0}'.": "Tentative de requête du type du module non initialisé '{0}'.",
        "Tried to set variable type to uninitialized module type '{0}'.": "Tentative de définir le type de variable sur un type de module non initialisé '{0}'.",
        "Type '{0}' does not have type parameters.": "Le type '{0}' n'a pas de paramètres de type.",
        "Getters must return a value.": "Les accesseurs Get doivent retourner une valeur.",
        "Getter and setter accessors do not agree in visibility.": "Les accesseurs Get et Set ne sont pas en accord sur la visibilité.",
        "Invalid left-hand side of assignment expression.": "Partie gauche de l'expression d'assignation non valide.",
        "Function declared a non-void return type, but has no return expression.": "La fonction a déclaré un type de retour non void, mais n'a pas d'expression de retour.",
        "Cannot resolve return type reference.": "Impossible de résoudre la référence de type de retour.",
        "Constructors cannot have a return type of 'void'.": "Les constructeurs ne peuvent pas avoir le type de retour 'void'.",
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": "Les déclarations de variable ultérieures doivent avoir le même type. La variable '{0}' doit être de type '{1}', mais elle a ici le type '{2}'.",
        "All symbols within a with block will be resolved to 'any'.": "Tous les symboles d'un bloc with seront résolus en 'any'.",
        "Import declarations in an internal module cannot reference an external module.": "Les déclarations Import d'un module interne ne peuvent pas référencer un module externe.",
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": "La classe {0} déclare l'interface {1} mais ne l'implémente pas :{NL}{2}",
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": "La classe {0} déclare la classe {1} comme une interface, mais ne l'implémente pas :{NL}{2}",
        "The operand of an increment or decrement operator must be a variable, property or indexer.": "L'opérande d'un opérateur d'incrémentation ou de décrémentation doit être une variable, une propriété ou un indexeur.",
        "'this' cannot be referenced in static initializers in a class body.": "'this' ne peut pas être référencé dans les initialiseurs statiques d'un corps de classe.",
        "Class '{0}' cannot extend class '{1}':{NL}{2}": "La classe '{0}' ne peut pas étendre la classe '{1}' :{NL}{2}",
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": "L'interface '{0}' ne peut pas étendre la classe '{1}' :{NL}{2}",
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": "L'interface '{0}' ne peut pas étendre l'interface '{1}' :{NL}{2}",
        "Duplicate overload signature for '{0}'.": "Dupliquer la signature de surcharge pour '{0}'.",
        "Duplicate constructor overload signature.": "Dupliquer la signature de surcharge du constructeur.",
        "Duplicate overload call signature.": "Dupliquer la signature d'appel de surcharge.",
        "Duplicate overload construct signature.": "Dupliquer la signature de construction de surcharge.",
        "Overload signature is not compatible with function definition.": "La signature de surcharge n'est pas compatible avec la définition de fonction.",
        "Overload signature is not compatible with function definition:{NL}{0}": "La signature de surcharge n'est pas compatible avec la définition de fonction :{NL}{0}",
        "Overload signatures must all be public or private.": "Les signatures de surcharge doivent toutes être publiques ou privées.",
        "Overload signatures must all be exported or not exported.": "Les signatures de surcharge doivent toutes être exportées ou non exportées.",
        "Overload signatures must all be ambient or non-ambient.": "Les signatures de surcharge doivent toutes être ambiantes ou non ambiantes.",
        "Overload signatures must all be optional or required.": "Les signatures de surcharge doivent toutes être facultatives ou requises.",
        "Specialized overload signature is not assignable to any non-specialized signature.": "La signature de surcharge spécialisée n'est assignable à aucune signature non spécialisée.",
        "'this' cannot be referenced in constructor arguments.": "'this' ne peut pas être référencé dans les arguments de constructeur.",
        "Instance member cannot be accessed off a class.": "Impossible d'accéder à un membre d'instance à partir d'une classe.",
        "Untyped function calls may not accept type arguments.": "Les appels de fonctions non typées ne peuvent pas accepter d'arguments de type.",
        "Non-generic functions may not accept type arguments.": "Les fonctions non génériques ne peuvent pas accepter d'arguments de type.",
        "A generic type may not reference itself with a wrapped form of its own type parameters.": "Un type générique ne peut pas faire référence à lui-même avec une forme de ses propres paramètres de type incluse dans un wrapper.",
        "Rest parameters must be array types.": "Les paramètres rest doivent être des types tableau.",
        "Overload signature implementation cannot use specialized type.": "L'implémentation de signature de surcharge ne peut pas utiliser de type spécialisé.",
        "Export assignments may only be used at the top-level of external modules.": "Les assignations d'exportation peuvent seulement être utilisées au niveau supérieur des modules externes.",
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules.": "Les assignations d'exportation peuvent être effectuées uniquement avec des variables, des fonctions, des classes, des interfaces, des énumérations et des modules internes.",
        "Only public methods of the base class are accessible via the 'super' keyword.": "Seules les méthodes publiques de la classe de base sont accessibles via le mot clé 'super'.",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}'.": "Le type d'indexeur numérique '{0}' doit être assignable au type d'indexeur de chaîne '{1}'.",
        "Numeric indexer type '{0}' must be assignable to string indexer type '{1}':{NL}{2}": "Le type d'indexeur numérique '{0}' doit être assignable au type d'indexeur de chaîne '{1}' :{NL}{2}",
        "All numerically named properties must be assignable to numeric indexer type '{0}'.": "Toutes les propriétés nommées numériquement doivent être assignables au type d'indexeur numérique '{0}'.",
        "All numerically named properties must be assignable to numeric indexer type '{0}':{NL}{1}": "Toutes les propriétés nommées numériquement doivent être assignables au type d'indexeur numérique '{0}' : {NL}{1}",
        "All named properties must be assignable to string indexer type '{0}'.": "Toutes les propriétés nommées doivent être assignables au type d'indexeur de chaîne '{0}'.",
        "All named properties must be assignable to string indexer type '{0}':{NL}{1}": "Toutes les propriétés nommées doivent être assignables au type d'indexeur de chaîne '{0}' : {NL}{1}",
        "Generic type references must include all type arguments.": "Les références de type générique doivent inclure tous les arguments de type.",
        "Default arguments are only allowed in implementation.": "Les arguments par défaut sont autorisés uniquement dans l'implémentation.",
        "Overloads cannot differ only by return type.": "Les surcharges ne peuvent pas différer uniquement par le type de retour.",
        "Function expression declared a non-void return type, but has no return expression.": "L'expression de fonction a déclaré un type de retour non void, mais n'a pas d'expression de retour.",
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": "La déclaration Import qui référence l'identificateur à partir du module interne peut uniquement être effectuée avec des variables, fonctions, classes, interfaces, enums et des modules internes.",
        "Could not find symbol '{0}' in module '{1}'.": "Impossible de trouver le symbole '{0}' dans le module '{1}'.",
        "Unable to resolve module reference '{0}'.": "Impossible de résoudre la référence de module '{0}'.",
        "Could not find module '{0}' in module '{1}'.": "Impossible de trouver le module '{0}' dans le module '{1}'.",
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": "La déclaration Import exportée '{0}' est une valeur assignée avec un type qui a ou utilise un type privé '{1}'.",
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": "La déclaration Import exportée '{0}' est une valeur assignée avec un type qui utilise un module inaccessible '{1}'.",
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": "La déclaration Import exportée '{0}' est un type assigné qui a ou utilise un type privé '{1}'.",
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": "La déclaration Import exportée '{0}' est un type assigné qui utilise un module inaccessible '{1}'.",
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": "La déclaration Import exportée '{0}' est un conteneur assigné qui est ou utilise un module inaccessible '{1}'.",
        "Type name '{0}' in extends clause does not reference constructor function for '{1}'.": "Le nom de type '{0}' dans la clause extends ne fait pas référence à la fonction de constructeur pour '{1}'.",
        "Internal module reference '{0}' in import declaration does not reference module instance for '{1}'.": "La référence de module interne '{0}' dans la déclaration d'importation ne fait pas référence à l'instance de module pour '{1}'.",
        "Module '{0}' cannot merge with previous declaration of '{1}' in a different file '{2}'.": "Le module '{0}' ne peut pas être fusionné avec la déclaration précédente de '{1}' dans un fichier différent '{2}'.",
        "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}':{NL}{3}": "L'interface '{0}' ne peut pas étendre simultanément les types '{1}' et '{2}':{NL}{3}",
        "Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.": "L'initialiseur du paramètre '{0}' ne peut pas faire référence à l'identificateur '{1}' déclaré après lui.",
        "Ambient external module declaration cannot be reopened.": "La déclaration de module externe ambiante ne peut pas être rouverte.",
        "All declarations of merged declaration '{0}' must be exported or not exported.": "Toutes les déclarations de la déclaration fusionnée '{0}' doivent être exportées ou non exportées.",
        "'super' cannot be referenced in constructor arguments.": "'super' ne peut pas être référencé dans des arguments de constructeur.",
        "Return type of constructor signature must be assignable to the instance type of the class.": "Le type de retour de la signature du constructeur doit pouvoir être assigné au type d'instance de la classe.",
        "Ambient external module declaration must be defined in global context.": "La déclaration de module externe ambiante doit être définie dans le contexte global.",
        "Ambient external module declaration cannot specify relative module name.": "La déclaration de module externe ambiante ne peut pas spécifier de nom de module relatif.",
        "Import declaration in an ambient external module declaration cannot reference external module through relative external module name.": "La déclaration d'importation dans une déclaration de module externe ambiante ne peut pas faire référence au module externe par l'intermédiaire du nom de module externe relatif.",
        "Could not find the best common type of types of all return statement expressions.": "Impossible de trouver le meilleur type commun des types de toutes les expressions d'instruction de retour.",
        "Import declaration cannot refer to external module reference when --noResolve option is set.": "La déclaration d'importation ne peut pas faire référence à une référence de module externe lorsque l'option --noResolve est définie.",
        "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.": "Identificateur dupliqué '_this'. Le compilateur utilise la déclaration de variable '_this' pour capturer la référence 'this'.",
        "'continue' statement can only be used within an enclosing iteration statement.": "L'instruction 'continue' peut être utilisée uniquement dans une instruction d'itération englobante.",
        "'break' statement can only be used within an enclosing iteration or switch statement.": "L'instruction 'break' peut être utilisée uniquement dans une itération englobante ou une instruction switch.",
        "Jump target not found.": "Cible de saut introuvable.",
        "Jump target cannot cross function boundary.": "La cible du saut ne peut pas traverser une limite de fonction.",
        "Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.": "Identificateur dupliqué '_super'. Le compilateur utilise '_super' pour capturer la référence de classe de base.",
        "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.": "Expression résolue en déclaration de variable '_this' et utilisée par le compilateur pour capturer la référence 'this'.",
        "Expression resolves to '_super' that compiler uses to capture base class reference.": "Expression résolue en '_super' et utilisée par le compilateur pour capturer la référence de classe de base.",
        "TypeParameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": "Le TypeParameter '{0}' de signature de constructeur de l'interface exportée possède ou utilise le type privé '{1}'.",
        "TypeParameter '{0}' of call signature from exported interface has or is using private type '{1}'.": "Le TypeParameter '{0}' de signature d'appel de l'interface exportée possède ou utilise le type privé '{1}'.",
        "TypeParameter '{0}' of public static method from exported class has or is using private type '{1}'.": "Le TypeParameter '{0}' de méthode statique publique de classe exportée possède ou utilise le type privé '{1}'.",
        "TypeParameter '{0}' of public method from exported class has or is using private type '{1}'.": "Le TypeParameter '{0}' de méthode publique de classe exportée possède ou utilise le type privé '{1}'.",
        "TypeParameter '{0}' of method from exported interface has or is using private type '{1}'.": "Le TypeParameter '{0}' de méthode d'interface exportée possède ou utilise le type privé '{1}'.",
        "TypeParameter '{0}' of exported function has or is using private type '{1}'.": "Le TypeParameter '{0}' de fonction exportée possède ou utilise le type privé '{1}'.",
        "TypeParameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": "Le TypeParameter '{0}' de signature de constructeur de l'interface exportée utilise le module inaccessible {1}.",
        "TypeParameter '{0}' of call signature from exported interface is using inaccessible module {1}": "Le TypeParameter '{0}' de signature d'appel de l'interface exportée utilise le module inaccessible {1}",
        "TypeParameter '{0}' of public static method from exported class is using inaccessible module {1}.": "Le TypeParameter '{0}' de méthode statique publique de classe exportée utilise le module inaccessible {1}.",
        "TypeParameter '{0}' of public method from exported class is using inaccessible module {1}.": "Le TypeParameter '{0}' de méthode publique de classe exportée utilise le module inaccessible {1}.",
        "TypeParameter '{0}' of method from exported interface is using inaccessible module {1}.": "Le TypeParameter '{0}' de méthode d'interface exportée utilise le module inaccessible {1}.",
        "TypeParameter '{0}' of exported function is using inaccessible module {1}.": "Le TypeParameter '{0}' de fonction exportée utilise le module inaccessible {1}.",
        "TypeParameter '{0}' of exported class has or is using private type '{1}'.": "Le TypeParameter '{0}' de classe exportée possède ou utilise le type privé '{1}'.",
        "TypeParameter '{0}' of exported interface has or is using private type '{1}'.": "Le TypeParameter '{0}' d'interface exportée possède ou utilise le type privé '{1}'.",
        "TypeParameter '{0}' of exported class is using inaccessible module {1}.": "Le TypeParameter '{0}' de classe exportée utilise le module inaccessible {1}.",
        "TypeParameter '{0}' of exported interface is using inaccessible module {1}.": "Le TypeParameter '{0}' d'interface exportée utilise le module inaccessible {1}.",
        "Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.": "Identificateur dupliqué '_i'. Le compilateur utilise '_i' pour initialiser le paramètre rest.",
        "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.": "Identificateur dupliqué 'arguments'. Le compilateur utilise 'arguments' pour initialiser les paramètres rest.",
        "Type of conditional '{0}' must be identical to '{1}' or '{2}'.": "Le type de conditionnel '{0}' doit être identique à '{1}' ou '{2}'.",
        "Type of conditional '{0}' must be identical to '{1}', '{2}' or '{3}'.": "Le type de conditionnel '{0}' doit être identique à '{1}', '{2}' ou '{3}'.",
        "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.": "Identificateur dupliqué '{0}'. Le compilateur réserve le nom '{1}' dans la portée de niveau supérieur d'un module externe.",
        "Constraint of a type parameter cannot reference any type parameter from the same type parameter list.": "La contrainte d'un paramètre de type ne peut pas faire référence à un paramètre de type de la même liste de paramètres de type.",
        "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.": "L'initialiseur de la variable membre d'instance '{0}' ne peut pas faire référence à l'identificateur '{1}' déclaré dans le constructeur.",
        "Parameter '{0}' cannot be referenced in its initializer.": "Le paramètre '{0}' ne peut pas être référencé dans son initialiseur.",
        "Duplicate string index signature.": "Signature d'index de chaîne dupliquée.",
        "Duplicate number index signature.": "Signature d'index de nombre dupliquée.",
        "All declarations of an interface must have identical type parameters.": "Toutes les déclarations d'une interface doivent avoir des paramètres de type identiques.",
        "Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.": "L'expression est résolue en la déclaration de variable '_i' utilisée par le compilateur pour initialiser le paramètre rest.",
        "Type '{0}' is missing property '{1}' from type '{2}'.": "Le type '{0}' ne contient pas la propriété '{1}' du type '{2}'.",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": "Les types de propriété '{0}' des types '{1}' et '{2}' sont incompatibles.",
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": "Les types de propriétés '{0}' des types '{1}' et '{2}' sont incompatibles :{NL}{3}",
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "La propriété '{0}' définie comme privée dans le type '{1}' est définie comme publique dans le type '{2}'.",
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "La propriété '{0}' définie comme publique dans le type '{1}' est définie comme privée dans le type '{2}'.",
        "Types '{0}' and '{1}' define property '{2}' as private.": "Les types '{0}' et '{1}' définissent la propriété '{2}' comme privée.",
        "Call signatures of types '{0}' and '{1}' are incompatible.": "Les signatures d'appel de types '{0}' et '{1}' sont incompatibles.",
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "Les signatures d'appel de types '{0}' et '{1}' sont incompatibles :{NL}{2}",
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": "Le type '{0}' requiert une signature d'appel, mais le type '{1}' n'en possède pas.",
        "Construct signatures of types '{0}' and '{1}' are incompatible.": "Les signatures de construction de types '{0}' et '{1}' sont incompatibles.",
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "Les signatures de construction de types '{0}' et '{1}' sont incompatibles :{NL}{2}",
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": "Le type '{0}' requiert une signature du constructeur, mais le type '{1}' n'en possède pas.",
        "Index signatures of types '{0}' and '{1}' are incompatible.": "Les signatures d'index de types '{0}' et '{1}' sont incompatibles.",
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": "Les signatures d'index de types '{0}' et '{1}' sont incompatibles :{NL}{2}",
        "Call signature expects {0} or fewer parameters.": "La signature d'appel attend au maximum {0} paramètres.",
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": "Impossible d'appliquer le type '{0}' à l'argument {1} qui est de type '{2}'.",
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": "La classe '{0}' définit l'accesseur de membre d'instance '{1}', mais la classe étendue '{2}' le définit comme fonction de membre d'instance.",
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": "La classe '{0}' définit la propriété de membre d'instance '{1}', mais la classe étendue '{2}' le définit comme fonction de membre d'instance.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": "La classe '{0}' définit la fonction de membre d'instance '{1}', mais la classe étendue '{2}' le définit comme accesseur de membre d'instance.",
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": "La classe '{0}' définit la fonction de membre d'instance '{1}', mais la classe étendue '{2}' le définit comme propriété de membre d'instance.",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": "Les types de propriétés statiques '{0}' des classes '{1}' et '{2}' sont incompatibles.",
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": "Les types de propriétés statiques '{0}' des classes '{1}' et '{2}' sont incompatibles :{NL}{3}",
        "Type reference cannot refer to container '{0}'.": "La référence de type ne peut pas faire référence au conteneur '{0}'.",
        "Type reference must refer to type.": "La référence de type doit faire référence au type.",
        "In enums with multiple declarations only one declaration can omit an initializer for the first enum element.": "Dans les énumérations avec plusieurs déclarations, une seule déclaration peut omettre un initialiseur pour le premier élément de l'énumération.",
        " (+ {0} overload(s))": " (+ {0} surcharge(s))",
        "Variable declaration cannot have the same name as an import declaration.": "Une déclaration de variable ne peut pas avoir le même nom qu'une déclaration d'importation.",
        "Signature expected {0} type arguments, got {1} instead.": "La signature attendait {0} arguments de type, mais en a reçu {1}.",
        "Property '{0}' defined as optional in type '{1}', but is required in type '{2}'.": "La propriété '{0}' est définie comme facultative dans le type '{1}', mais elle est requise dans le type '{2}'.",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference do not refer to same named type.": "Les types '{0}' et '{1}' ayant pour origine une référence de type à expansion infinie ne font pas référence au même type nommé.",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments.": "Les types '{0}' et '{1}' ayant pour origine une référence de type à expansion infinie ont des arguments de type incompatibles.",
        "Types '{0}' and '{1}' originating in infinitely expanding type reference have incompatible type arguments:{NL}{2}": "Les types '{0}' et '{1}' ayant pour origine une référence de type à expansion infinie ont des arguments de type incompatibles :{NL}{2}",
        "Named properties '{0}' of types '{1}' and '{2}' are not identical.": "Les propriétés nommées '{0}' de types '{1}' et '{2}' ne sont pas identiques.",
        "Types of string indexer of types '{0}' and '{1}' are not identical.": "Les types d'indexeur de chaîne des types '{0}' et '{1}' ne sont pas identiques.",
        "Types of number indexer of types '{0}' and '{1}' are not identical.": "Les types d'indexeur de nombre des types '{0}' et '{1}' ne sont pas identiques.",
        "Type of number indexer in type '{0}' is not assignable to string indexer type in type '{1}'.{NL}{2}": "Le type d'indexeur de nombre dans le type '{0}' n'est pas assignable au type d'indexeur de chaîne dans le type '{1}'.{NL}{2}",
        "Type of property '{0}' in type '{1}' is not assignable to string indexer type in type '{2}'.{NL}{3}": "Le type de propriété {0} dans le type '{1}' n'est pas assignable au type d'indexeur de chaîne dans le type '{2}'.{NL}{3}",
        "Type of property '{0}' in type '{1}' is not assignable to number indexer type in type '{2}'.{NL}{3}": "Le type de propriété {0} dans le type '{1}' n'est pas assignable au type d'indexeur de nombre dans le type '{2}'.{NL}{3}",
        "Static property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": "La propriété statique '{0}' définie comme privée dans le type '{1}' est définie comme publique dans le type '{2}'.",
        "Static property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": "La propriété statique '{0}' définie comme publique dans le type '{1}' est définie comme privée dans le type '{2}'.",
        "Types '{0}' and '{1}' define static property '{2}' as private.": "Les types '{0}' et '{1}' définissent la propriété statique '{2}' comme privée.",
        "Current host does not support '{0}' option.": "L'hôte actuel ne prend pas en charge l'option '{0}'.",
        "ECMAScript target version '{0}' not supported.  Specify a valid target version: '{1}' (default), or '{2}'": "Version cible ECMAScript '{0}' non prise en charge. Spécifiez une version cible valide : '{1}' (par défaut) ou '{2}'",
        "Module code generation '{0}' not supported.": "Génération de code de module '{0}' non prise en charge.",
        "Could not find file: '{0}'.": "Fichier : '{0}' introuvable.",
        "A file cannot have a reference to itself.": "Un fichier ne peut pas contenir une référence à lui-même.",
        "Cannot resolve referenced file: '{0}'.": "Impossible de résoudre le fichier référencé : '{0}'.",
        "Cannot find the common subdirectory path for the input files.": "Impossible de trouver le chemin d'accès au sous-répertoire commun pour les fichiers d'entrée.",
        "Emit Error: {0}.": "Émettre l'erreur : {0}.",
        "Cannot read file '{0}': {1}": "Impossible de lire le fichier '{0}' : {1}",
        "Unsupported file encoding.": "Encodage de fichier non pris en charge.",
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": "Les paramètres régionaux doivent être sous la forme <langue> ou <langue>-<territoire>. Par exemple '{0}' ou '{1}'.",
        "Unsupported locale: '{0}'.": "Paramètres régionaux non pris en charge : '{0}'.",
        "Execution Failed.{NL}": "L'exécution a échoué.{NL}",
        "Invalid call to 'up'": "Appel de 'up' non valide",
        "Invalid call to 'down'": "Appel de 'down' non valide",
        "Base64 value '{0}' finished with a continuation bit.": "Valeur Base64 '{0}' terminée par un bit de continuation.",
        "Unknown option '{0}'": "Option inconnue '{0}'",
        "Expected {0} arguments to message, got {1} instead.": "{0} arguments de message attendus. {1} reçus à la place.",
        "Expected the message '{0}' to have {1} arguments, but it had {2}": "{1} arguments étaient attendus dans le message '{0}', mais il en contenait {2}",
        "Could not delete file '{0}'": "Impossible de supprimer le fichier '{0}'",
        "Could not create directory '{0}'": "Impossible de créer le répertoire '{0}'",
        "Error while executing file '{0}': ": "Erreur lors de l'exécution du fichier : '{0}' : ",
        "Cannot compile external modules unless the '--module' flag is provided.": "Impossible de compiler les modules externes, sauf si l'indicateur '--module' est fourni.",
        "Option mapRoot cannot be specified without specifying sourcemap option.": "Impossible de spécifier l'option mapRoot sans spécifier l'option de mappage de source.",
        "Option sourceRoot cannot be specified without specifying sourcemap option.": "Impossible de spécifier l'option sourceRoot sans spécifier l'option de mappage de source.",
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": "Impossible de spécifier les options mapRoot et sourceRoot sans spécifier l'option de mappage de source.",
        "Option '{0}' specified without '{1}'": "Option '{0}' spécifiée sans '{1}'",
        "'codepage' option not supported on current platform.": "Option 'codepage' non prise en charge sur la plateforme actuelle.",
        "Concatenate and emit output to single file.": "Concaténer la sortie et l'émettre vers un seul fichier.",
        "Generates corresponding {0} file.": "Génère le fichier {0} correspondant.",
        "Specifies the location where debugger should locate map files instead of generated locations.": "Spécifie l'emplacement dans lequel le débogueur doit localiser les fichiers de mappage plutôt que les emplacements générés.",
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": "Spécifie l'emplacement dans lequel le débogueur doit localiser les fichiers TypeScript plutôt que les emplacements source.",
        "Watch input files.": "Fichiers d'entrée d'espion.",
        "Redirect output structure to the directory.": "Rediriger la structure de sortie vers le répertoire.",
        "Do not emit comments to output.": "Ne pas publier de commentaires dans la sortie.",
        "Skip resolution and preprocessing.": "Ignorer la résolution et le prétraitement.",
        "Specify ECMAScript target version: '{0}' (default), or '{1}'": "Spécifiez la version cible ECMAScript : '{0}' (par défaut) ou '{1}'",
        "Specify module code generation: '{0}' or '{1}'": "Spécifiez la génération du code de module : '{0}' ou '{1}'",
        "Print this message.": "Imprimer ce message.",
        "Print the compiler's version: {0}": "Imprimer la version du compilateur : {0}",
        "Allow use of deprecated '{0}' keyword when referencing an external module.": "Autoriser l'utilisation du mot clé déconseillé '{0}' lors de la référence à un module externe.",
        "Specify locale for errors and messages. For example '{0}' or '{1}'": "Spécifiez les paramètres régionaux pour les erreurs et les messages. Par exemple '{0}' ou '{1}'",
        "Syntax:   {0}": "Syntaxe :   {0}",
        "options": "options",
        "file1": "fichier",
        "Examples:": "Exemples :",
        "Options:": "Options :",
        "Insert command line options and files from a file.": "Insérer les options de ligne de commande et les fichiers à partir d'un fichier texte.",
        "Version {0}": "Version {0}",
        "Use the '{0}' flag to see options.": "Utilisez l'indicateur '{0}' pour afficher les options.",
        "{NL}Recompiling ({0}):": "{NL} Recompilation en cours ({0}) :",
        "STRING": "CHAÎNE",
        "KIND": "GENRE",
        "file2": "FICHIER",
        "VERSION": "VERSION",
        "LOCATION": "EMPLACEMENT",
        "DIRECTORY": "RÉPERTOIRE",
        "NUMBER": "NOMBRE",
        "Specify the codepage to use when opening source files.": "Spécifiez la page de codes à utiliser à l'ouverture des fichiers sources.",
        "Additional locations:": "Emplacements supplémentaires :",
        "This version of the Javascript runtime does not support the '{0}' function.": "Cette version du runtime JavaScript ne prend pas en charge la fonction '{0}'.",
        "Unknown rule.": "Règle inconnue.",
        "Invalid line number ({0})": "Numéro de ligne non valide ({0})",
        "Warn on expressions and declarations with an implied 'any' type.": "Avertit en cas d'expressions et de déclarations possédant un type 'any' implicite.",
        "Variable '{0}' implicitly has an 'any' type.": "La variable '{0}' possède implicitement un type 'any'.",
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": "Le paramètre '{0}' de '{1}' possède implicitement un type 'any'.",
        "Parameter '{0}' of function type implicitly has an 'any' type.": "Le paramètre '{0}' du type de fonction possède implicitement un type 'any'.",
        "Member '{0}' of object type implicitly has an 'any' type.": "Le membre '{0}' du type d'objet possède implicitement un type 'any'.",
        "'new' expression, which lacks a constructor signature, implicitly has an 'any' type.": "L'expression 'new', pour laquelle il manque une signature de constructeur, a un type implicite 'any'.",
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": "'{0}', qui ne dispose pas d'annotation de type de retour, possède implicitement un type 'any'.",
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": "L'expression de fonction, qui ne dispose pas d'annotation de type de retour, possède implicitement un type 'any'.",
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": "Le paramètre '{0}' de la fonction lamda possède implicitement un type 'any'.",
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": "La signature du constructeur, qui ne dispose pas d'annotation de type de retour, possède implicitement un type 'any'.",
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": "La fonction lambda, qui ne dispose pas d'annotation de type de retour, possède implicitement un type 'any'.",
        "Array Literal implicitly has an 'any' type from widening.": "Le littéral de tableau possède implicitement un type 'any' à partir de la conversion étendue.",
        "'{0}', which lacks 'get' accessor and parameter type annotation on 'set' accessor, implicitly has an 'any' type.": "'{0}', pour lequel il manque un accesseur 'get' et une annotation de type de paramètre sur l'accesseur 'set', a un type implicite 'any'.",
        "Index signature of object type implicitly has an 'any' type.": "La signature d'index du type d'objet a implicitement un type 'any'.",
        "Object literal's property '{0}' implicitly has an 'any' type from widening.": "La propriété '{0}' du littéral d'objet a un type implicite 'any' suite à l'élargissement."
}